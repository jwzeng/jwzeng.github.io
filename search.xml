<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode腾讯精选练习50题（89. 格雷编码）</title>
    <url>/2019/08/25/leetCodeTencent50-50/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 2</div><div class="line">输出: [0,1,3,2]</div><div class="line">解释:</div><div class="line">00 - 0</div><div class="line">01 - 1</div><div class="line">11 - 3</div><div class="line">10 - 2</div><div class="line"></div><div class="line">对于给定的 n，其格雷编码序列并不唯一。</div><div class="line">例如，[0,2,3,1] 也是一个有效的格雷编码序列。</div><div class="line"></div><div class="line">00 - 0</div><div class="line">10 - 2</div><div class="line">11 - 3</div><div class="line">01 - 1</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 0</div><div class="line">输出: [0]</div><div class="line">解释: 我们定义格雷编码序列必须以 0 开头。</div><div class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。</div><div class="line">     因此，当 n = 0 时，其格雷编码序列为 [0]。</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/gray-code" target="_blank" rel="external">https://leetcode-cn.com/problems/gray-code</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>不懂格雷码，百度了一下，发现了下面的构造规则：</p>
<ol>
<li>1位格雷码有两个码字</li>
<li>(n+1)位格雷码中的前2^n个码字等于n位格雷码的码字，按顺序书写，加前缀0</li>
<li>(n+1)位格雷码中的后2^n个码字等于n位格雷码的码字，按逆序书写，加前缀1</li>
<li>n+1位格雷码的集合 = n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1</li>
</ol>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Binary-reflected_Gray_code_construction.svg/220px-Binary-reflected_Gray_code_construction.svg.png" alt="img"></p>
<p>根据上面的规则可以用迭代或递归来解决</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">          <span class="keyword">return</span> [<span class="number">0</span>]</div><div class="line">        result = [<span class="string">'0'</span>, <span class="string">'1'</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</div><div class="line">          add = result[::<span class="number">-1</span>]	<span class="comment">#逆序</span></div><div class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result)):</div><div class="line">            result[i] = <span class="string">'0'</span> + result[i]	<span class="comment"># 加前缀0</span></div><div class="line">            add[i] = <span class="string">'1'</span> + add[i]		<span class="comment"># 加前缀1</span></div><div class="line">          result += add					<span class="comment"># n+1位 = n位(顺序) + n位(逆序)</span></div><div class="line">        <span class="keyword">return</span> [int(i, <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> result]	<span class="comment"># 二进制转换为十进制</span></div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>格雷编码</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（46. 全排列）</title>
    <url>/2019/08/25/leetCodeTencent50-49/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="external">https://leetcode-cn.com/problems/permutations</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>类似于78. 子集子集那一题，那题是每个元素加和不加入子集的选择。这题是每个元素插入位置的选择。</p>
<p>首先是第一个元素插入，只有1个位置；接着是第二个元素的插入，有2个位置，可以插入在第一个元素的前面和后面；接着是第三个元素的插入，有3个位置，….。</p>
<p>最后是1<em> 2</em> 3<em> …</em> n = n!，符合全排列的n!种排列方式的结果。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> nums:</div><div class="line">        <span class="keyword">return</span> [[]]</div><div class="line">      result = [[nums[<span class="number">0</span>]]]</div><div class="line">      newresult = []</div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):	<span class="comment"># 遍历每个元素</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(result)):	<span class="comment"># 遍历前i-1个元素排好的所有序列</span></div><div class="line">          <span class="keyword">for</span> k <span class="keyword">in</span> range(len(result[j])+<span class="number">1</span>):	<span class="comment"># 遍历第i个元素的插入位置</span></div><div class="line">            a = result[j].copy()</div><div class="line">            a.insert(k, nums[i])</div><div class="line">            newresult.append(a)</div><div class="line">        result = newresult</div><div class="line">        newresult = []</div><div class="line">      <span class="keyword">return</span> result</div><div class="line"><span class="comment"># 优化</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> nums:</div><div class="line">        <span class="keyword">return</span> [[]]</div><div class="line">      result = [[nums[<span class="number">0</span>]]]</div><div class="line">      newresult = []</div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:	<span class="comment"># 遍历每个元素</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> result:	<span class="comment"># 遍历前面元素排好的所有序列</span></div><div class="line">          <span class="keyword">for</span> k <span class="keyword">in</span> range(len(j)+<span class="number">1</span>):	<span class="comment"># 遍历i的插入位置</span></div><div class="line">            newresult.append(j[:k] + [i] + j[k:])</div><div class="line">        result = newresult</div><div class="line">        newresult = []</div><div class="line">      <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（70. 爬楼梯）</title>
    <url>/2019/08/25/leetCodeTencent50-48/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入： 2</div><div class="line">输出： 2</div><div class="line">解释： 有两种方法可以爬到楼顶。</div><div class="line">1.  1 阶 + 1 阶</div><div class="line">2.  2 阶</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入： 3</div><div class="line">输出： 3</div><div class="line">解释： 有三种方法可以爬到楼顶。</div><div class="line">1.  1 阶 + 1 阶 + 1 阶</div><div class="line">2.  1 阶 + 2 阶</div><div class="line">3.  2 阶 + 1 阶</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="external">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题是动态规划的典型应用，n阶楼梯可以由n-1阶走1阶得到，或者由由n-2阶走2阶得到.对应的递推式为result[n] = result[n-1] + result[n-2]</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></div><div class="line">        result = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</div><div class="line">          result[i] = result[i<span class="number">-1</span>] + result[i<span class="number">-2</span>]</div><div class="line">        <span class="keyword">return</span> result[n]</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>爬楼梯</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（557. 反转字符串中的单词 III）</title>
    <url>/2019/08/25/leetCodeTencent50-47/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;Let&apos;s take LeetCode contest&quot;</div><div class="line">输出: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="external">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题用spilt切分，然后用[::-1]反转，最后用” “.join连接</p>
<p>看了下别人的，方法是用的一样的，但竟然能简化到一行</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">        sList = s.split()</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sList)):</div><div class="line">          sList[i] = sList[i][::<span class="number">-1</span>]</div><div class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(sList)</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(i[::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> s.split())</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>反转字符串中的单词 III</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（14. 最长公共前缀）</title>
    <url>/2019/08/25/leetCodeTencent50-46/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</div><div class="line">输出: &quot;fl&quot;</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</div><div class="line">输出: &quot;&quot;</div><div class="line">解释: 输入不存在公共前缀。</div></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="external">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题直接暴力遍历每个字符串的第1，2，…个字母是否相等即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></div><div class="line">        result = <span class="string">''</span></div><div class="line">        index = <span class="number">0</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">          <span class="keyword">while</span> <span class="keyword">True</span>:            </div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)<span class="number">-1</span>):</div><div class="line">              <span class="keyword">if</span> strs[i][index] != strs[i+<span class="number">1</span>][index]:</div><div class="line">                <span class="keyword">return</span> result</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">              result += strs[<span class="number">0</span>][index]</div><div class="line">            index += <span class="number">1</span></div><div class="line">        <span class="keyword">except</span>:</div><div class="line">          <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>最长公共前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（5. 最长回文子串）</title>
    <url>/2019/08/23/leetCodeTencent50-45/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;babad&quot;</div><div class="line">输出: &quot;bab&quot;</div><div class="line">注意: &quot;aba&quot; 也是一个有效答案。</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;cbbd&quot;</div><div class="line">输出: &quot;bb&quot;</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="external">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先想到的是暴力计算所有的字串，第一个字符开头的子串n个，第二个字符开头的子串n-1个，…。n + n-1 + … + 1 = n(n-1)/2种，这光遍历就有O（n2）复杂度了，内部判断是不是回文字串还要遍历一遍，时间复杂度都O(n3)了，肯定超时不可取。</p>
<p>第二个想到的是把字符串反转，而回文子串反转与原子串一样。所以问题可以变为原字符串和反转字符串的最长公共字串。而最长公共子串和最长公共子序列是动态规划的经典应用，最长公共子串的递推式为：length（i，j）=length（i-1，j-1）+1，if  s[i-1] = _s[j-1] else 0。最后取所有中最长的一个length对应的字串。</p>
<p>但是测试后发现，”aacdefcaa”这种用例会出现错误，尾部的caa倒过来会等于acc。必须加一个约束，回文字串反转后与它相同的必须是它自己，不能是其他位置的。索引m位置的字符反转后的索引为len(s)-1 - m,所以可以用这个来判断是不是它自己。</p>
<p>虽然改好了，但最后还是超时了。最后去看了下别人的，其中比较容易理解的是中心扩展算法，遍历每一个可能是回文子串对称中心的位置，假设字符串含有n个字符，则可能的对称中心有2n-1个。因为偶数长度的回文字串的对称中心是间一个字母（如aba），奇数长度的对称中心是中间两个字母的空隙（如abba）。n个字符有n个字母和n-1个空隙，所以有2n-1个可能的对称中心。所以只要遍历这2n-1对称中心，看它们的左右两边是否相等即可。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">      _s = s[::<span class="number">-1</span>]</div><div class="line">      length = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(_s)+<span class="number">1</span>)]</div><div class="line">      count = <span class="number">0</span></div><div class="line">      endIndex = <span class="number">0</span></div><div class="line">      result = <span class="string">''</span></div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)+<span class="number">1</span>):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(_s)+<span class="number">1</span>):</div><div class="line">          <span class="keyword">if</span> s[i<span class="number">-1</span>] == _s[j<span class="number">-1</span>]:</div><div class="line">            length[i][j] = length[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></div><div class="line">          <span class="keyword">if</span> length[i][j] &gt; count:</div><div class="line">            <span class="keyword">if</span> i - length[i][j] == len(s) - j:	<span class="comment"># 判断反转后与它相同的是不是它自己</span></div><div class="line">              count = length[i][j]</div><div class="line">              endIndex = i<span class="number">-1</span></div><div class="line">      <span class="keyword">for</span> k <span class="keyword">in</span> range(endIndex, endIndex-count, <span class="number">-1</span>):</div><div class="line">        result += s[k]</div><div class="line">      <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">      count = <span class="number">0</span></div><div class="line">      centerIndex = <span class="number">0</span></div><div class="line">      result = <span class="string">''</span></div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</div><div class="line">        length1 = self.expandCenter(s, i, i)	<span class="comment"># 奇数长度</span></div><div class="line">        length2 = self.expandCenter(s, i, i+<span class="number">1</span>)	<span class="comment"># 偶数长度</span></div><div class="line">        length = max(length1, length2)</div><div class="line">        <span class="keyword">if</span> length &gt; count:</div><div class="line">          count = length</div><div class="line">          centerIndex = i</div><div class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(centerIndex - (count<span class="number">-1</span>)//<span class="number">2</span>, centerIndex + count//<span class="number">2</span> + <span class="number">1</span>):</div><div class="line">        result += s[j]</div><div class="line">      <span class="keyword">return</span> result</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandCenter</span><span class="params">(self, s, left, right)</span>:</span>    </div><div class="line">      <span class="keyword">while</span>(left&gt;=<span class="number">0</span> <span class="keyword">and</span> right&lt;len(s) <span class="keyword">and</span> s[left]==s[right] ):</div><div class="line">        left -= <span class="number">1</span></div><div class="line">        right += <span class="number">1</span></div><div class="line">      <span class="keyword">return</span> right - left - <span class="number">1</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（344. 反转字符串）</title>
    <url>/2019/08/23/leetCodeTencent50-44/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</div><div class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</div><div class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="external">https://leetcode-cn.com/problems/reverse-string</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这不就是反转数组吗，直接交换就行了</p>
<p>用python更是可以用索引直接反转</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Do not return anything, modify s in-place instead.</div><div class="line">        """</div><div class="line">        n = len(s)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n//<span class="number">2</span>):</div><div class="line">          s[i], s[n<span class="number">-1</span>-i] = s[n<span class="number">-1</span>-i], s[i]</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        s[<span class="number">0</span>:] = s[::<span class="number">-1</span>]</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（43. 字符串相乘）</title>
    <url>/2019/08/23/leetCodeTencent50-43/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</div><div class="line">输出: &quot;6&quot;</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</div><div class="line">输出: &quot;56088&quot;</div></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>num1 和 num2 的长度小于110。</li>
<li>num1 和 num2 只包含数字 0-9。</li>
<li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li>
<li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/multiply-strings" target="_blank" rel="external">https://leetcode-cn.com/problems/multiply-strings</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>看到题和示例就浮现转为数字类型后直接计算的想法，但一看题目难度中等，应该没这么简单，果然说明后要求不能用直接转为整数计算，那就是只能把字符每一位转为数字后计算。</p>
<p>想了想直接按原始的乘法过程计算好像可以：就是小学列竖式计算时，下面乘数的最后一位乘以上面的每一位得到一行，再依次十位、百位乘以上面的每一位都得到一行；再把得到的每一行相加就是最后结果。但这样太麻烦了，两个乘数两层遍历，要进位，数百位等要补0，最后还要相加。</p>
<p>那除了这样还能怎么遍历呢，刚才是从乘数也就是输入遍历，反过来就是从输出也就是乘法结果遍历。结果的个位数只能是乘数的个位<em> 个位的尾数，十位是个位</em> 十位或十位<em> 个位，…。所以当<strong>结果位数索引k = 乘数位数索引i + 乘数位数索引j </strong>时就进行计算。最后的结果 = 个位的结果 + 十位的结果</em> 10 + 百位的结果* 100 + …</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></div><div class="line">        n = len(num1) + len(num2)</div><div class="line">        num1 = num1[::<span class="number">-1</span>]</div><div class="line">        num2 = num2[::<span class="number">-1</span>]</div><div class="line">        data = [<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(n)]</div><div class="line">        result = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n<span class="number">-1</span>):	<span class="comment"># 按相乘结果位数遍历</span></div><div class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> i &gt; len(num1)<span class="number">-1</span> <span class="keyword">or</span> k-i &gt; len(num2)<span class="number">-1</span>:</div><div class="line">              <span class="keyword">continue</span></div><div class="line">            data[k] += int(num1[i]) * int(num2[k-i])</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n<span class="number">-1</span>):</div><div class="line">          result += <span class="number">10</span>**k * data[k]</div><div class="line">        <span class="keyword">return</span> str(result)</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（9. 回文数）</title>
    <url>/2019/08/23/leetCodeTencent50-42/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 121</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: -121</div><div class="line">输出: false</div><div class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</div></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 10</div><div class="line">输出: false</div><div class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</div></pre></td></tr></table></figure>
<p><strong>进阶:</strong></p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="external">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>不用字符串的话，这题就是前面反转整数一样的思路。反转整数是直接不断对10取余得到每位上的数字，最后取出每一位计算。这题前面取余是一样的，后面改成每一位与它对应位（如第一位和最后一位）比较大小，或者比较反转后的整数与原整数的大小。</p>
<p>转成字符串其实思路也差不多，只是不用取余了，因为字符串自带索引，可以直接取到每一位数字字符。</p>
<p>看了下官方的，不用反转整个整数与原整数比较，反转一半就行了。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></div><div class="line">      <span class="keyword">if</span> x &lt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">      <span class="keyword">if</span> x == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">      result = []</div><div class="line">      <span class="keyword">while</span> x &gt; <span class="number">0</span>:</div><div class="line">        result.append(x%<span class="number">10</span>)	<span class="comment"># 取余</span></div><div class="line">        x = x // <span class="number">10</span></div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result)//<span class="number">2</span>):</div><div class="line">        <span class="keyword">if</span> result[i] != result[len(result)<span class="number">-1</span>-i]:	<span class="comment"># 比较大小</span></div><div class="line">          <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">      <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="comment"># 优化</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></div><div class="line">      <span class="keyword">if</span> x &lt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">      <span class="keyword">if</span> x == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">      y = x</div><div class="line">      data = <span class="number">0</span></div><div class="line">      <span class="keyword">while</span> y &gt; <span class="number">0</span>:</div><div class="line">        res = y%<span class="number">10</span></div><div class="line">        y = y // <span class="number">10</span></div><div class="line">        data = data*<span class="number">10</span> + res</div><div class="line">      <span class="keyword">return</span> data == x</div></pre></td></tr></table></figure>
<p><strong>代码2 :</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></div><div class="line">      <span class="keyword">if</span> x &lt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">      <span class="keyword">if</span> x == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">      x = str(x)</div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)//<span class="number">2</span>):</div><div class="line">        <span class="keyword">if</span> x[i] != x[len(x)<span class="number">-1</span>-i]:</div><div class="line">          <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">      <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p><strong>代码3 :</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></div><div class="line">      <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x != <span class="number">0</span> <span class="keyword">and</span> x%<span class="number">10</span> == <span class="number">0</span>):</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">      <span class="keyword">if</span> x == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">      data = <span class="number">0</span></div><div class="line">      <span class="keyword">while</span> x &gt; data:</div><div class="line">        res = x%<span class="number">10</span></div><div class="line">        x = x // <span class="number">10</span></div><div class="line">        data = data*<span class="number">10</span> + res</div><div class="line">      <span class="keyword">return</span> x == data <span class="keyword">or</span> x == data//<span class="number">10</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（8. 字符串转换整数 (atoi)）</title>
    <url>/2019/08/22/leetCodeTencent50-41/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;42&quot;</div><div class="line">输出: 42</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;   -42&quot;</div><div class="line">输出: -42</div><div class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</div><div class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</div></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;4193 with words&quot;</div><div class="line">输出: 4193</div><div class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</div></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;words and 987&quot;</div><div class="line">输出: 0</div><div class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</div><div class="line">     因此无法执行有效的转换。</div></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;-91283472332&quot;</div><div class="line">输出: -2147483648</div><div class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </div><div class="line">     因此返回 INT_MIN (−231) 。</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="external">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>只想到到分类讨论排除解决，比较麻烦，直接看了下别人的可以用正则表达式解决。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></div><div class="line">        <span class="comment">#去掉左边空字符</span></div><div class="line">        str=str.lstrip()</div><div class="line">        <span class="comment">#如果字符串空，返回</span></div><div class="line">        <span class="keyword">if</span> len(str)==<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="comment">#设置默认输出为0</span></div><div class="line">        last=<span class="number">0</span></div><div class="line">        <span class="comment">#如果有符号设置起始位置2，其余的为1</span></div><div class="line">        i=<span class="number">2</span> <span class="keyword">if</span> str[<span class="number">0</span>]==<span class="string">'-'</span><span class="keyword">or</span> str[<span class="number">0</span>]==<span class="string">'+'</span>  <span class="keyword">else</span> <span class="number">1</span></div><div class="line">        <span class="comment">#循环，直到无法强转成int，跳出循环</span></div><div class="line">        <span class="keyword">while</span> i &lt;= len(str):</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                last=int(str[:i])</div><div class="line">                i+=<span class="number">1</span></div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        <span class="comment">#如果数字超出范围，返回范围最大值</span></div><div class="line">        <span class="keyword">if</span> last&lt;<span class="number">-2147483648</span> :</div><div class="line">            <span class="keyword">return</span> <span class="number">-2147483648</span></div><div class="line">        <span class="keyword">if</span> last&gt;<span class="number">2147483647</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">2147483647</span></div><div class="line">        <span class="keyword">return</span> last</div></pre></td></tr></table></figure>
<p><strong>代码2 :</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></div><div class="line">      str = re.findall(<span class="string">'^[\+\-]?\d+'</span>, str.lstrip())</div><div class="line">      data = int(*str)</div><div class="line">      <span class="keyword">return</span> max(min(data, <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>), <span class="number">-2</span>**<span class="number">31</span>)</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（7. 整数反转）</title>
    <url>/2019/08/22/leetCodeTencent50-40/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 123</div><div class="line">输出: 321</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: -123</div><div class="line">输出: -321</div></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 120</div><div class="line">输出: 21</div></pre></td></tr></table></figure>
<p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="external">https://leetcode-cn.com/problems/reverse-integer</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>直接不断对10取余得到每位上的数字，用flag保存正负标志，最后取出每一位计算即可。</p>
<p>但在取余的过程中发现了一个问题，python的取余机制和java竟然不一样：</p>
<ul>
<li><p><strong>python</strong>:    123%10 = 3,    123%-10 = -7,    -123%10 = 7,    -123%-10 = -3</p>
</li>
<li><p><strong>java:</strong>    123%10 = 3,    123%-10 = 3,    -123%10 = -3,    -123%-10 = -3</p>
</li>
</ul>
<p>为了避免这个问题还是把负数变成正数计算比较好。</p>
<p>看了下别人的，不需要用list保存，即取即用就行。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></div><div class="line">      <span class="keyword">if</span> x == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">      result = []</div><div class="line">      data = <span class="number">0</span></div><div class="line">      flag = <span class="keyword">False</span></div><div class="line">      <span class="keyword">if</span> x &gt; <span class="number">0</span>:</div><div class="line">        result.append(x%<span class="number">10</span>)</div><div class="line">        x = x // <span class="number">10</span></div><div class="line">      <span class="keyword">else</span>:</div><div class="line">        flag = <span class="keyword">True</span></div><div class="line">        result.append(-(x%<span class="number">-10</span>))</div><div class="line">        x = x // <span class="number">-10</span></div><div class="line">      <span class="keyword">while</span> x &gt; <span class="number">0</span>:</div><div class="line">        result.append(x%<span class="number">10</span>)</div><div class="line">        x = x // <span class="number">10</span></div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result)):</div><div class="line">        data = data*<span class="number">10</span> + result[i]</div><div class="line">      <span class="keyword">if</span> flag:</div><div class="line">        data = -data</div><div class="line">      <span class="keyword">if</span> data &gt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">and</span> data &lt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</div><div class="line">        <span class="keyword">return</span> data</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line"><span class="comment"># 复数改成正数计算</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></div><div class="line">      <span class="keyword">if</span> x == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">      result = []</div><div class="line">      data = <span class="number">0</span></div><div class="line">      flag = <span class="keyword">False</span></div><div class="line">      <span class="keyword">if</span> x &lt; <span class="number">0</span>:</div><div class="line">        flag = <span class="keyword">True</span></div><div class="line">        x = -x</div><div class="line">      <span class="keyword">while</span> x &gt; <span class="number">0</span>:</div><div class="line">        result.append(x%<span class="number">10</span>)</div><div class="line">        x = x // <span class="number">10</span></div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result)):</div><div class="line">        data = data*<span class="number">10</span> + result[i]</div><div class="line">      <span class="keyword">if</span> flag:</div><div class="line">        data = -data</div><div class="line">      <span class="keyword">if</span> data &gt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">and</span> data &lt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</div><div class="line">        <span class="keyword">return</span> data</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p><strong>代码 :</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></div><div class="line">      <span class="keyword">if</span> x == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">      data = <span class="number">0</span></div><div class="line">      flag = <span class="keyword">False</span></div><div class="line">      <span class="keyword">if</span> x &lt; <span class="number">0</span>:</div><div class="line">        flag = <span class="keyword">True</span></div><div class="line">        x = -x</div><div class="line">      <span class="keyword">while</span> x &gt; <span class="number">0</span>:</div><div class="line">        res = x%<span class="number">10</span></div><div class="line">        x = x // <span class="number">10</span></div><div class="line">        data = data*<span class="number">10</span> + res</div><div class="line">      <span class="keyword">if</span> flag:</div><div class="line">        data = -data</div><div class="line">      <span class="keyword">if</span> data &gt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">and</span> data &lt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</div><div class="line">        <span class="keyword">return</span> data</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（237. 删除链表中的节点）</title>
    <url>/2019/08/22/leetCodeTencent50-39/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: head = [4,5,1,9], node = 5</div><div class="line">输出: [4,1,9]</div><div class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: head = [4,5,1,9], node = 1</div><div class="line">输出: [4,5,9]</div><div class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</div></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list" target="_blank" rel="external">https://leetcode-cn.com/problems/delete-node-in-a-linked-list</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题真是醉了，画图示例描述了一大堆，结果只对题目造成误解。在说明中说链表中的值唯一的，给人一种按值遍历链表找要删除结点的感觉，结果看方法形参只给了一个，嗯~~，原来前面了那么多描述，全是废话。什么值是唯一的一点用都没有。</p>
<p>直接说给定链表中一个特定节点（不是尾节点）请删除该节点就行了，顶多再提示一下该节点就是链表中的点，不是链表外的其它结点。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type node: ListNode</div><div class="line">        :rtype: void Do not return anything, modify node in-place instead.</div><div class="line">        """</div><div class="line">        node.val = node.next.val</div><div class="line">        node.next = node.next.next</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（206. 反转链表）</title>
    <url>/2019/08/22/leetCodeTencent50-38/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>反转一个单链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</div><div class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</div></pre></td></tr></table></figure>
<ul>
<li><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="external">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先是直接保存到数组里，倒序排好后再放回链表。</p>
<p>然后是用链表实现，将该链表每个节点在新的链表从后往前放入即可。</p>
<p>递归的话，第一层是头结点和已经反转好的其他节点链表（从第二层返回），要做的就是把它两拼起来，反转好的链表的尾结点刚好就是第二个结点，所以要做的就是把头结点发在第二个结点后面</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></div><div class="line">      data = []</div><div class="line">      <span class="keyword">while</span> head:</div><div class="line">        data.append(head.val)</div><div class="line">        head = head.next</div><div class="line">      data.reverse()</div><div class="line">      res = h = ListNode(<span class="number">0</span>)</div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</div><div class="line">        h.next = ListNode(data[i])</div><div class="line">        h = h.next</div><div class="line">      <span class="keyword">return</span> res.next</div><div class="line"><span class="comment"># 优化</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></div><div class="line">      res = h = ListNode(<span class="number">0</span>)</div><div class="line">      h.next = head</div><div class="line">      data = []</div><div class="line">      <span class="keyword">while</span> head:</div><div class="line">        data.append(head.val)</div><div class="line">        head = head.next</div><div class="line">      data.reverse()</div><div class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</div><div class="line">        h = h.next</div><div class="line">        h.val = data[i]</div><div class="line">      <span class="keyword">return</span> res.next</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></div><div class="line">      res = ListNode(<span class="number">0</span>)</div><div class="line">      <span class="keyword">while</span> head:</div><div class="line">        h = head.next	<span class="comment"># 缓存下一节点</span></div><div class="line">        head.next = res.next	<span class="comment"># 插入到新的链表</span></div><div class="line">        res.next = head</div><div class="line">        head = h	<span class="comment"># 复原到下一节点</span></div><div class="line">      <span class="keyword">return</span> res.next</div></pre></td></tr></table></figure>
<p><strong>代码 3:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> head:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> head.next:</div><div class="line">        <span class="keyword">return</span> head</div><div class="line">      endNode = head.next	<span class="comment"># 第二个结点，即反转好的新的链表的尾结点</span></div><div class="line">      newHead = self.reverseList(endNode) <span class="comment"># 反转好的链表的头结点</span></div><div class="line">      endNode.next = head	<span class="comment"># 第一个结点拼接到第二个结点（尾结点）后面</span></div><div class="line">      head.next = <span class="keyword">None</span>	<span class="comment"># 第一个结点成为新的尾结点</span></div><div class="line">      <span class="keyword">return</span> newHead</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（160. 相交链表）</title>
    <url>/2019/08/22/leetCodeTencent50-37/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p>
<p>在节点 c1 开始相交。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</div><div class="line">输出：Reference of the node with value = 8</div><div class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</div><div class="line">输出：Reference of the node with value = 2</div><div class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>示例 3:</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</div><div class="line">输出：null</div><div class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</div><div class="line">解释：这两个链表不相交，因此返回 null。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p>注意：</p>
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="external">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>跟前两题一样，用哈希表。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head1, head1: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        data = &#123;&#125;</div><div class="line">        <span class="keyword">while</span> headA <span class="keyword">or</span> headB:</div><div class="line">            <span class="keyword">if</span> headA:</div><div class="line">                <span class="keyword">if</span> headA <span class="keyword">in</span> data:</div><div class="line">                    <span class="keyword">return</span> headA</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    data[headA] = <span class="number">1</span></div><div class="line">                headA = headA.next</div><div class="line">            <span class="keyword">if</span> headB:</div><div class="line">                <span class="keyword">if</span> headB <span class="keyword">in</span> data:</div><div class="line">                    <span class="keyword">return</span> headB</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    data[headB] = <span class="number">1</span></div><div class="line">                headB = headB.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（142. 环形链表 II）</title>
    <url>/2019/08/22/leetCodeTencent50-36/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：head = [3,2,0,-4], pos = 1</div><div class="line">输出：tail connects to node index 1</div><div class="line">解释：链表中有一个环，其尾部连接到第二个节点。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：head = [1,2], pos = 0</div><div class="line">输出：tail connects to node index 0</div><div class="line">解释：链表中有一个环，其尾部连接到第一个节点。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：head = [1], pos = -1</div><div class="line">输出：no cycle</div><div class="line">解释：链表中没有环。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p><strong>进阶：</strong></p>
<p>你是否可以不用额外空间解决此题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="external">https://leetcode-cn.com/problems/linked-list-cycle-ii</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>跟上一题一样，用哈希表。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        """</div><div class="line">        data = &#123;&#125;</div><div class="line">        <span class="keyword">while</span> head:</div><div class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> data:</div><div class="line">                <span class="keyword">return</span> head</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                data[head] = <span class="number">1</span></div><div class="line">            head = head.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（141. 环形链表）</title>
    <url>/2019/08/22/leetCodeTencent50-35/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：head = [3,2,0,-4], pos = 1</div><div class="line">输出：true</div><div class="line">解释：链表中有一个环，其尾部连接到第二个节点。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：head = [1,2], pos = 0</div><div class="line">输出：true</div><div class="line">解释：链表中有一个环，其尾部连接到第一个节点。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：head = [1], pos = -1</div><div class="line">输出：false</div><div class="line">解释：链表中没有环。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p><strong>进阶：</strong></p>
<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="external">https://leetcode-cn.com/problems/linked-list-cycle</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>找环就是找重复结点，重复一般用哈希表。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode(object):</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        data = &#123;&#125;</div><div class="line">        <span class="keyword">while</span> head:</div><div class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> data:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                data[head] = <span class="number">1</span></div><div class="line">            head = head.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（61. 旋转链表）</title>
    <url>/2019/08/22/leetCodeTencent50-34/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</div><div class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</div><div class="line">解释:</div><div class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</div><div class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4</div><div class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</div><div class="line">解释:</div><div class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</div><div class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</div><div class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</div><div class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-list" target="_blank" rel="external">https://leetcode-cn.com/problems/rotate-list</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先当然是保存到数组，用数组移动，然后又放回链表。</p>
<p>接下来用链表操作，与数组直接交换值不同，链表直接移动结点(值不变)。而移动有两种方法，一种所有节点往后移动1步，循环k次。另一种是直接往后移动k步。很明显第二种更简单，因为只要把数据的倒数第k个结点开始截断，再把最后一个结点拼在第一个结点前即可。所以关键是找到最后一个结点和倒数第k个结点。</p>
<p>问题是怎么找到倒数第k个结点，倒数第k个=顺数第（length-k+1）个，所以只要求出链表的长度即可，遍历一遍计数就行。</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        h = res = ListNode(<span class="number">0</span>)</div><div class="line">        data = []</div><div class="line">        <span class="keyword">while</span> head:</div><div class="line">            data.append(head.val)</div><div class="line">            head = head.next</div><div class="line">        k = k % len(data)</div><div class="line">        data2 = data.copy()</div><div class="line">        data[k:len(data)] = data2[<span class="number">0</span>:len(data)-k]</div><div class="line">        data[<span class="number">0</span>:k] = data2[len(data)-k:len(data)]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</div><div class="line">            node = ListNode(data[i])</div><div class="line">            h.next = node</div><div class="line">            h = h.next</div><div class="line">        <span class="keyword">return</span> res.next</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        length = <span class="number">1</span>	<span class="comment"># 长度</span></div><div class="line">        endNode = head	<span class="comment"># 尾结点</span></div><div class="line">        <span class="keyword">while</span> endNode.next:</div><div class="line">            length += <span class="number">1</span></div><div class="line">            endNode = endNode.next</div><div class="line">        k = k % length	</div><div class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> head</div><div class="line">        count = <span class="number">1</span></div><div class="line">        kEndNode = head	<span class="comment"># 倒数第k个结点	</span></div><div class="line">        <span class="keyword">while</span> kEndNode:</div><div class="line">            <span class="keyword">if</span> count == length - k :</div><div class="line">                newEndNode = kEndNode</div><div class="line">                kEndNode = kEndNode.next	</div><div class="line">                newEndNode.next = <span class="keyword">None</span>	<span class="comment"># 截断</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">            count += <span class="number">1</span></div><div class="line">            kEndNode = kEndNode.next</div><div class="line">        endNode.next = head	<span class="comment"># 拼接</span></div><div class="line">        <span class="keyword">return</span> kEndNode</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（21. 合并两个有序链表）</title>
    <url>/2019/08/22/leetCodeTencent50-33/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</div><div class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>看到有序链表合并就想到有序数组的归并排序，根据头部的大小依次保存进一个新的数组即可。本题思路一样，只是要注意题目要求拼接两个链表的结点，所以不要用新的链表保存</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></div><div class="line">        head = res = ListNode(<span class="number">0</span>)</div><div class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</div><div class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</div><div class="line">                head.next = l1</div><div class="line">                l1 = l1.next</div><div class="line">                head = head.next</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                head.next = l2</div><div class="line">                l2 = l2.next</div><div class="line">                head = head.next</div><div class="line">        <span class="keyword">if</span> l1:</div><div class="line">            head.next = l1</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            head.next = l2</div><div class="line">        <span class="keyword">return</span> res.next</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（2. 两数相加）</title>
    <url>/2019/08/22/leetCodeTencent50-32/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</div><div class="line">输出：7 -&gt; 0 -&gt; 8</div><div class="line">原因：342 + 465 = 807</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="external">https://leetcode-cn.com/problems/add-two-numbers</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先当然是转为整型数据直接计算，然后再保存回来。</p>
<p>然后是链表计算，从头到尾遍历就行，只是要相加大于10要进位</p>
<p>看了下别人的答案，思路跟我的差不多，不过while和下面的if中的代码基本一样，可以并在一起，比我的跟精简</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></div><div class="line">        nums1 = <span class="number">0</span></div><div class="line">        tenNum = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> l1:</div><div class="line">            nums1 += l1.val * tenNum</div><div class="line">            tenNum *= <span class="number">10</span></div><div class="line">            l1 = l1.next</div><div class="line">        nums2 = <span class="number">0</span></div><div class="line">        tenNum = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> l2:</div><div class="line">            nums2 += l2.val * tenNum</div><div class="line">            tenNum *= <span class="number">10</span></div><div class="line">            l2 = l2.next</div><div class="line">        result = nums1 + nums2</div><div class="line">        data = result % <span class="number">10</span></div><div class="line">        head = res = ListNode(data)</div><div class="line">        result = result // <span class="number">10</span></div><div class="line">        <span class="keyword">while</span> result &gt; <span class="number">0</span>:</div><div class="line">            data = result % <span class="number">10</span></div><div class="line">            node = ListNode(data)</div><div class="line">            head.next = node</div><div class="line">            head = head.next</div><div class="line">            result = result // <span class="number">10</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></div><div class="line">        head = res = ListNode(<span class="number">0</span>)</div><div class="line">        data = <span class="number">0</span></div><div class="line">        flag = <span class="keyword">False</span>	<span class="comment"># 进位标志</span></div><div class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</div><div class="line">            <span class="keyword">if</span> flag:</div><div class="line">                data = l1.val + l2.val + <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                data = l1.val + l2.val</div><div class="line">            <span class="keyword">if</span> data &lt; <span class="number">10</span>:</div><div class="line">                flag = <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                flag = <span class="keyword">True</span></div><div class="line">                data = data % <span class="number">10</span></div><div class="line">            node = ListNode(data)</div><div class="line">            head.next = node</div><div class="line">            head = head.next</div><div class="line">            l1 = l1.next</div><div class="line">            l2 = l2.next</div><div class="line">        <span class="keyword">if</span> l1:</div><div class="line">            <span class="keyword">while</span> l1:</div><div class="line">                <span class="keyword">if</span> flag:</div><div class="line">                    data = l1.val + <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    data = l1.val</div><div class="line">                <span class="keyword">if</span> data &lt; <span class="number">10</span>:</div><div class="line">                    flag = <span class="keyword">False</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    flag = <span class="keyword">True</span></div><div class="line">                    data = data % <span class="number">10</span></div><div class="line">                node = ListNode(data)</div><div class="line">                head.next = node</div><div class="line">                head = head.next</div><div class="line">                l1 = l1.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">while</span> l2:</div><div class="line">                <span class="keyword">if</span> flag:</div><div class="line">                    data = l2.val + <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    data = l2.val</div><div class="line">                <span class="keyword">if</span> data &lt; <span class="number">10</span>:</div><div class="line">                    flag = <span class="keyword">False</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    flag = <span class="keyword">True</span></div><div class="line">                    data = data % <span class="number">10</span></div><div class="line">                node = ListNode(data)</div><div class="line">                head.next = node</div><div class="line">                head = head.next</div><div class="line">                l2 = l2.next            </div><div class="line">        <span class="keyword">if</span> flag:</div><div class="line">            node = ListNode(<span class="number">1</span>)</div><div class="line">            head.next = node</div><div class="line">            head = head.next</div><div class="line">        <span class="keyword">return</span> res.next</div><div class="line"><span class="comment"># 优化</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></div><div class="line">        head = res = ListNode(<span class="number">0</span>)</div><div class="line">        data = <span class="number">0</span></div><div class="line">        flag = <span class="keyword">False</span></div><div class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</div><div class="line">            x = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></div><div class="line">            y = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></div><div class="line">            <span class="keyword">if</span> flag:</div><div class="line">                data = x + y + <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                data = x + y</div><div class="line">            <span class="keyword">if</span> data &lt; <span class="number">10</span>:</div><div class="line">                flag = <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                flag = <span class="keyword">True</span></div><div class="line">                data = data % <span class="number">10</span></div><div class="line">            node = ListNode(data)</div><div class="line">            head.next = node</div><div class="line">            head = head.next</div><div class="line">            <span class="keyword">if</span> l1:</div><div class="line">                l1 = l1.next</div><div class="line">            <span class="keyword">if</span> l2:</div><div class="line">                l2 = l2.next          </div><div class="line">        <span class="keyword">if</span> flag:</div><div class="line">            node = ListNode(<span class="number">1</span>)</div><div class="line">            head.next = node</div><div class="line">            head = head.next</div><div class="line">        <span class="keyword">return</span> res.next</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（238. 除自身以外数组的乘积）</title>
    <url>/2019/08/21/leetCodeTencent50-31/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3,4]</div><div class="line">输出: [24,12,8,6]</div></pre></td></tr></table></figure>
<p>说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p>进阶：<br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/product-of-array-except-self" target="_blank" rel="external">https://leetcode-cn.com/problems/product-of-array-except-self</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先直接暴击计算，测试果然超出了时间限制。</p>
<p>题目要求O(n)的时间复杂度，只能单层遍历，只能把总乘积分成左右两边乘积来算。</p>
<p>要满足常数空间复杂度，左右乘积不能用数组来保存了，只能用单个值来保存了。这就意味着要现算现用，用完就不用缓存了。</p>
<p>看了下别人的代码，时间复杂度竟然还能更小，两个for能在一个for里实现</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></div><div class="line">        output = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</div><div class="line">                <span class="keyword">if</span> j == i:</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                output[i] *= nums[j]</div><div class="line">        <span class="keyword">return</span> output</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></div><div class="line">        output = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</div><div class="line">        left = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</div><div class="line">        right = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</div><div class="line">            left[i] = left[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            right[j] = right[j+<span class="number">1</span>] * nums[j+<span class="number">1</span>]</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(nums)):</div><div class="line">            output[k] = left[k] * right[k]</div><div class="line">        <span class="keyword">return</span> output</div><div class="line"><span class="comment"># 改进</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></div><div class="line">        output = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</div><div class="line">        right = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</div><div class="line">            output[i] = output[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            right = right * nums[j+<span class="number">1</span>]</div><div class="line">            output[j] *= right</div><div class="line">        <span class="keyword">return</span> output</div></pre></td></tr></table></figure>
<p><strong>代码 3:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></div><div class="line">        output = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</div><div class="line">        left = <span class="number">1</span></div><div class="line">        right = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</div><div class="line">            left = left * nums[i<span class="number">-1</span>]</div><div class="line">            output[i] *= left</div><div class="line">            right = right * nums[len(nums)-i]</div><div class="line">            output[len(nums)-i<span class="number">-1</span>] *= right</div><div class="line">        <span class="keyword">return</span> output</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（217. 存在重复元素）</title>
    <url>/2019/08/21/leetCodeTencent50-30/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3,1]</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3,4]</div><div class="line">输出: false。</div></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,1,1,3,3,4,3,2,4,2]</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="external">https://leetcode-cn.com/problems/contains-duplicate/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先是利用python自带的set,测试好像也能通过。</p>
<p>正常来写肯定是用哈希表了</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></div><div class="line">        s = set(nums)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(s) &lt; len(nums) <span class="keyword">else</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></div><div class="line">        data = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> data:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                data[i] = <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（121. 买卖股票的最佳时机）</title>
    <url>/2019/08/21/leetCodeTencent50-29/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [7,1,5,3,6,4]</div><div class="line">输出: 5</div><div class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</div><div class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [7,6,4,3,1]</div><div class="line">输出: 0</div><div class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="external">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先用暴力遍历，用每个元素后面最大的值减去该元素，得到每个元素买入时的最大利润，最后取最大的即可，测试后超时了。稍微去掉了一些不必要的值，结果还是超时。</p>
<p>仔细观察了一下，发现是max求每个元素后面的最大值花太多时间了。继续改进了一下，改成从后往前遍历，求最大值就可以记忆保存了</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></div><div class="line">        result = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices) - <span class="number">1</span>):</div><div class="line">            result = max(result, max(prices[i+<span class="number">1</span>:]) - prices[i])</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></div><div class="line">        result = <span class="number">0</span></div><div class="line">        leftmin = float(<span class="string">'inf'</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices) - <span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> prices[i] &gt;= leftmin:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                leftmin = prices[i]</div><div class="line">            result = max(result, max(prices[i+<span class="number">1</span>:]) - prices[i])</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p><strong>代码 3:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        result = <span class="number">0</span></div><div class="line">        rightmax = prices[len(prices)<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> prices[i] &gt;= rightmax:</div><div class="line">                rightmax = prices[i]</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            result = max(result, rightmax - prices[i])</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（88. 合并两个有序数组）</title>
    <url>/2019/08/21/leetCodeTencent50-28/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入:</div><div class="line">nums1 = [1,2,3,0,0,0], m = 3</div><div class="line">nums2 = [2,5,6],       n = 3</div><div class="line"></div><div class="line">输出: [1,2,2,3,5,6]</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="external">https://leetcode-cn.com/problems/merge-sorted-array</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先用list自带的排序方法看看，结果竟然通过了</p>
<p>接下来自己写排序方法，按理来说，两个排好序的数组比较适合归并排序，把两个数组按照头部大小依次放入一个新的数组即可。但从题目来看，希望用现成的nums1来保存结果，应该是想空间复杂度尽量低O(1)，所以比较合适的就是插入排序了。</p>
<p>看了下别人的，归并排序不用新的数组竟然也能实现，思路是把两个数组按照尾部大小（不包括0）依次放入一个num1尾部</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Do not return anything, modify nums1 in-place instead.</div><div class="line">        """</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</div><div class="line">            nums1[m+i] = nums2[i]</div><div class="line">        nums1.sort()</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Do not return anything, modify nums1 in-place instead.</div><div class="line">        """</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m+i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">                <span class="keyword">if</span> nums1[j] &lt;= nums2[i]:</div><div class="line">                    nums1[j+<span class="number">1</span>] = nums2[i]</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    nums1[j+<span class="number">1</span>] = nums1[j]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                nums1[<span class="number">0</span>] = nums2[i]</div></pre></td></tr></table></figure>
<p><strong>代码 3:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Do not return anything, modify nums1 in-place instead.</div><div class="line">        """       </div><div class="line">        one = m - <span class="number">1</span></div><div class="line">        two = n - <span class="number">1</span></div><div class="line">        total = m + n - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> one &gt;= <span class="number">0</span> <span class="keyword">and</span> two &gt;= <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> nums1[one] &lt;= nums2[two]:</div><div class="line">                nums1[total] = nums2[two]</div><div class="line">                two -= <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                nums1[total] = nums1[one]</div><div class="line">                one -= <span class="number">1</span></div><div class="line">            total -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> one &lt; <span class="number">0</span>:</div><div class="line">            nums1[:two+<span class="number">1</span>] = nums2[:two+<span class="number">1</span>]</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（62. 不同路径）</title>
    <url>/2019/08/20/leetCodeTencent50-27/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt="img"> </p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>说明：*</strong>m<em> 和 </em>n* 的值均不超过 100。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: m = 3, n = 2</div><div class="line">输出: 3</div><div class="line">解释:</div><div class="line">从左上角开始，总共有 3 条路径可以到达右下角。</div><div class="line">1. 向右 -&gt; 向右 -&gt; 向下</div><div class="line">2. 向右 -&gt; 向下 -&gt; 向右</div><div class="line">3. 向下 -&gt; 向右 -&gt; 向右</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="external">https://leetcode-cn.com/problems/unique-paths</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题跟前面的最长子序和一样，是动态规划的经典应用。每次只能向下或者向右移动一步，反过来说现在的位置只能由上面的或左面的移动一步得到的，于是得到了动态递推式：</p>
<p>到当前的位置路径数 = 到上面的位置路径数 + 到左面的位置路径数</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        result = [[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</div><div class="line">                result[j][i] = result[j<span class="number">-1</span>][i] + result[j][i<span class="number">-1</span>]</div><div class="line">        <span class="keyword">return</span> result[n<span class="number">-1</span>][m<span class="number">-1</span>]</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（59. 螺旋矩阵 II）</title>
    <url>/2019/08/20/leetCodeTencent50-26/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em>2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。   </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 3</div><div class="line">输出:</div><div class="line">[</div><div class="line"> [ 1, 2, 3 ],</div><div class="line"> [ 8, 9, 4 ],</div><div class="line"> [ 7, 6, 5 ]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="external">https://leetcode-cn.com/problems/spiral-matrix-ii/</a> </p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>与上题一样还是用4个指针，左left、右right、上up、下down，每四次一个循环：左到右、上到下、右到左、下到上，直到左右或上下指针相遇跳出循环，只是把从矩阵中取出值的动作改成赋值就行</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        left = <span class="number">0</span></div><div class="line">        right = n</div><div class="line">        up = <span class="number">0</span></div><div class="line">        down = n</div><div class="line">        data = <span class="number">1</span></div><div class="line">        result = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right):</div><div class="line">                result[up][i] = data</div><div class="line">                data += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> up == down - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            up += <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(up, down):</div><div class="line">                result[j][right<span class="number">-1</span>] = data</div><div class="line">                data += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> left == right - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            right -= <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right - <span class="number">1</span>, left - <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">                result[down<span class="number">-1</span>][i] = data</div><div class="line">                data += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> up == down - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            down -= <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(down <span class="number">-1</span>, up - <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">                result[j][left] = data</div><div class="line">                data += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> left == right - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            left += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（54. 螺旋矩阵）</title>
    <url>/2019/08/19/leetCodeTencent50-25/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。  </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入:</div><div class="line">[</div><div class="line"> [ 1, 2, 3 ],</div><div class="line"> [ 4, 5, 6 ],</div><div class="line"> [ 7, 8, 9 ]</div><div class="line">]</div><div class="line">输出: [1,2,3,6,9,8,7,4,5]</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入:</div><div class="line">[</div><div class="line">  [1, 2, 3, 4],</div><div class="line">  [5, 6, 7, 8],</div><div class="line">  [9,10,11,12]</div><div class="line">]</div><div class="line">输出: [1,2,3,4,8,12,11,10,9,5,6,7]</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/spiral-matrix" target="_blank" rel="external">https://leetcode-cn.com/problems/spiral-matrix</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题首先首先想到的就是用4个指针，左left、右right、上up、下down，每四次一个循环：左到右、上到下、右到左、下到上，直到左右或上下指针相遇跳出循环</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        result = []</div><div class="line">        left = <span class="number">0</span></div><div class="line">        right = len(matrix[<span class="number">0</span>])</div><div class="line">        up = <span class="number">0</span></div><div class="line">        down = len(matrix)</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right): <span class="comment"># 左到右</span></div><div class="line">                result.append(matrix[up][i])</div><div class="line">            <span class="keyword">if</span> up == down - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            up += <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(up, down):	<span class="comment"># 上到下</span></div><div class="line">                result.append(matrix[j][right<span class="number">-1</span>])</div><div class="line">            <span class="keyword">if</span> left == right - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            right -= <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right - <span class="number">1</span>, left - <span class="number">1</span>, <span class="number">-1</span>):	<span class="comment"># 右到左</span></div><div class="line">                result.append(matrix[down<span class="number">-1</span>][i])</div><div class="line">            <span class="keyword">if</span> up == down - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            down -= <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(down <span class="number">-1</span>, up - <span class="number">1</span>, <span class="number">-1</span>):	<span class="comment"># 下到上</span></div><div class="line">                result.append(matrix[j][left])</div><div class="line">            <span class="keyword">if</span> left == right - <span class="number">1</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            left += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（53. 最大子序和）</title>
    <url>/2019/08/19/leetCodeTencent50-24/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</div><div class="line">输出: 6</div><div class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</div></pre></td></tr></table></figure>
<p><strong>进阶:</strong></p>
<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="external">https://leetcode-cn.com/problems/maximum-subarray/</a> </p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题是动态规划的经典应用,动态规划表达式：</p>
<ul>
<li>如果前面的连续子序和sum&gt;0, sum = sum + num[i]</li>
<li>sum&lt;=0, sum =  num[i]</li>
</ul>
<p>最后在i求得的所以sum取最大的就是最大子序和result</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        s = nums[<span class="number">0</span>]</div><div class="line">        result = s</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</div><div class="line">            <span class="keyword">if</span> s &gt; <span class="number">0</span>:</div><div class="line">                s += nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                s = nums[i]</div><div class="line">            result = max(result, s)</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（33. 搜索旋转排序数组）</title>
    <url>/2019/08/19/leetCodeTencent50-23/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</div><div class="line">输出: 4</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</div><div class="line">输出: -1</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="external">https://leetcode-cn.com/problems/search-in-rotated-sorted-array</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>看到这个时间复杂度肯定要用二分法，但二分法要在有序的数组中才能实现。本题看似不是有序的数组，但实际从中间分开的两个数组，总有一个是有序的，所以只要把target跟这个有序的数组的头尾比较就行：</p>
<ul>
<li>如果nums[头] &lt; target &lt; nums[尾]，则有序的一半数组继续递归</li>
<li>否则在剩下的一半中继续递归</li>
</ul>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span><span class="params">(nums, left, right)</span>:</span></div><div class="line">            <span class="keyword">if</span> right - left == <span class="number">1</span>:</div><div class="line">                <span class="keyword">return</span> left <span class="keyword">if</span> nums[left] == target <span class="keyword">else</span> <span class="number">-1</span></div><div class="line">            mid_right = left + (right - left)//<span class="number">2</span></div><div class="line">            <span class="keyword">if</span> nums[left] &lt;=  nums[mid_right - <span class="number">1</span>]:	<span class="comment"># 判断有序还是无序</span></div><div class="line">                <span class="keyword">if</span> nums[left] == target:</div><div class="line">                    <span class="keyword">return</span> left</div><div class="line">                <span class="keyword">if</span> nums[mid_right - <span class="number">1</span>] == target:</div><div class="line">                    <span class="keyword">return</span> mid_right - <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> target &gt; nums[left] <span class="keyword">and</span> target &lt; nums[mid_right - <span class="number">1</span>]:</div><div class="line">                    <span class="keyword">return</span> findTarget(nums, left, mid_right)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> findTarget(nums, mid_right, right)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> nums[mid_right] == target:</div><div class="line">                    <span class="keyword">return</span> mid_right</div><div class="line">                <span class="keyword">if</span> nums[right - <span class="number">1</span>] == target:</div><div class="line">                    <span class="keyword">return</span> right - <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> target &gt; nums[mid_right] <span class="keyword">and</span> target &lt; nums[right - <span class="number">1</span>]:</div><div class="line">                    <span class="keyword">return</span> findTarget(nums, mid_right, right)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> findTarget(nums, left, mid_right)</div><div class="line">                    </div><div class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> <span class="number">-1</span></div><div class="line">        left = <span class="number">0</span></div><div class="line">        right = len(nums)</div><div class="line">        <span class="keyword">return</span> findTarget(nums, left, right)</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        ind = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>]:</div><div class="line">                ind += <span class="number">1</span></div><div class="line">                nums[ind] = nums[i+<span class="number">1</span>]</div><div class="line">        <span class="keyword">return</span> ind+<span class="number">1</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（26. 删除排序数组中的重复项）</title>
    <url>/2019/08/19/leetCodeTencent50-22/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定数组 nums = [1,1,2], </div><div class="line"></div><div class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </div><div class="line"></div><div class="line">你不需要考虑数组中超出新长度后面的元素。</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</div><div class="line"></div><div class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</div><div class="line"></div><div class="line">你不需要考虑数组中超出新长度后面的元素。</div></pre></td></tr></table></figure>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</div><div class="line">int len = removeDuplicates(nums);</div><div class="line"></div><div class="line">// 在函数里修改输入数组对于调用者是可见的。</div><div class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</div><div class="line">for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">    print(nums[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="external">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>因为是排序数组，所以想到的是当nums[i] == nums[i+1]，就删掉一个，结果虽然通过了，但有点慢；</p>
<p>刚才是采用删掉重复的，与之相反的是记住不同的，当nums[i] ！= nums[i+1]，就记住一个</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> i &lt; len(nums) - <span class="number">1</span>:</div><div class="line">            <span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</div><div class="line">                nums.pop(i+<span class="number">1</span>)</div><div class="line">                i -= <span class="number">1</span></div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> len(nums)</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        ind = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>]:</div><div class="line">                ind += <span class="number">1</span></div><div class="line">                nums[ind] = nums[i+<span class="number">1</span>]</div><div class="line">        <span class="keyword">return</span> ind+<span class="number">1</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（16. 最接近的三数之和）</title>
    <url>/2019/08/19/leetCodeTencent50-21/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</div><div class="line"></div><div class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum-closest" target="_blank" rel="external">https://leetcode-cn.com/problems/3sum-closest</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>与上一题三数之和基本相同，只要把threeSum与0比较，改称threeSum与target比较，因为只存在唯一答案，所以不需要去重</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></div><div class="line">        result =  float(<span class="string">'inf'</span>)</div><div class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        nums.sort()     <span class="comment"># 排序</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            left = i + <span class="number">1</span></div><div class="line">            right = len(nums) - <span class="number">1</span></div><div class="line">            <span class="keyword">while</span>(left &lt; right):</div><div class="line">                threeSum = nums[i] + nums[left] + nums[right]</div><div class="line">                gap = abs(threeSum - target)</div><div class="line">                <span class="keyword">if</span> abs(threeSum - target) &lt; abs(result - target):</div><div class="line">                    result = threeSum</div><div class="line">                <span class="keyword">if</span> threeSum == target:</div><div class="line">                    <span class="keyword">return</span> target</div><div class="line">                <span class="keyword">elif</span> threeSum &lt; target:</div><div class="line">                    left += <span class="number">1</span>	<span class="comment">#右移</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    right -= <span class="number">1</span>	<span class="comment">#左移</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（15. 三数之和）</title>
    <url>/2019/08/18/leetCodeTencent50-20/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</div><div class="line"></div><div class="line">满足要求的三元组集合为：</div><div class="line">[</div><div class="line">  [-1, 0, 1],</div><div class="line">  [-1, -1, 2]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="external">https://leetcode-cn.com/problems/3sum</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>暴力计算，果然超时，想了一会也只想到分成正的和负的两组再暴力结算，时间估计快不了多少。</p>
<p>最后参考了一下别人的：</p>
<ul>
<li>先将数组进行排序</li>
<li>从左侧开始，选定一个值为 <code>定值</code> </li>
<li>定义首和尾 </li>
<li>首尾与 <code>定值</code> 相加 <ul>
<li>等于 00，记录这三个值，首部右移，尾部左移</li>
<li>小于 00，首部右移</li>
<li>大于 00，尾部左移</li>
</ul>
</li>
<li>定值右移，重复该步骤</li>
</ul>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)<span class="number">-1</span>):</div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, len(nums)):</div><div class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="number">0</span>:</div><div class="line">                        result.append([nums[i], nums[j], nums[k]])</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result)<span class="number">-1</span>):</div><div class="line">            j = i + <span class="number">1</span> </div><div class="line">            <span class="keyword">while</span> j &lt; len(result):</div><div class="line">                a = result[i]</div><div class="line">                b = result[j]</div><div class="line">                a.sort()</div><div class="line">                b.sort()</div><div class="line">                <span class="keyword">if</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] <span class="keyword">and</span> a[<span class="number">1</span>] == b[<span class="number">1</span>] <span class="keyword">and</span> a[<span class="number">2</span>] == b[<span class="number">2</span>]:</div><div class="line">                    result.pop(j)</div><div class="line">                    j -= <span class="number">1</span></div><div class="line">                j += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p><strong>代码 2</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        nums.sort()     <span class="comment"># 排序</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</div><div class="line">                <span class="keyword">break</span>   <span class="comment"># 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></div><div class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</div><div class="line">                <span class="keyword">continue</span>    <span class="comment"># 去重</span></div><div class="line">            left = i + <span class="number">1</span></div><div class="line">            right = len(nums) - <span class="number">1</span></div><div class="line">            <span class="keyword">while</span>(left &lt; right):</div><div class="line">                <span class="keyword">if</span> nums[right] &lt; <span class="number">0</span>:</div><div class="line">                    <span class="keyword">break</span>   <span class="comment"># 如果当前数字小于0，则三数之和一定小于0，所以结束循环</span></div><div class="line">                threeSum = nums[i] + nums[left] + nums[right]</div><div class="line">                <span class="keyword">if</span> threeSum == <span class="number">0</span>:</div><div class="line">                    result.append([nums[i], nums[left], nums[right]])</div><div class="line">                    <span class="comment"># 去重</span></div><div class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</div><div class="line">                        left += <span class="number">1</span></div><div class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right<span class="number">-1</span>]:</div><div class="line">                        right -= <span class="number">1</span></div><div class="line">                    left += <span class="number">1</span></div><div class="line">                    right -= <span class="number">1</span></div><div class="line">                <span class="keyword">elif</span> threeSum &lt; <span class="number">0</span>:</div><div class="line">                    left += <span class="number">1</span>	<span class="comment">#右移</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    right -= <span class="number">1</span>	<span class="comment">#左移</span></div><div class="line">        <span class="keyword">return</span> result</div><div class="line"><span class="comment"># 修改</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        nums.sort()     <span class="comment"># 排序</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</div><div class="line">                <span class="keyword">break</span>   <span class="comment"># 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></div><div class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</div><div class="line">                <span class="keyword">continue</span>    <span class="comment"># 去重</span></div><div class="line">            left = i + <span class="number">1</span></div><div class="line">            right = len(nums) - <span class="number">1</span></div><div class="line">            <span class="keyword">while</span>(left &lt; right):</div><div class="line">                <span class="keyword">if</span> nums[right] &lt; <span class="number">0</span>:</div><div class="line">                    <span class="keyword">break</span>   <span class="comment"># 如果当前数字小于0，则三数之和一定小于0，所以结束循环</span></div><div class="line">                threeSum = nums[i] + nums[left] + nums[right]</div><div class="line">                <span class="keyword">if</span> threeSum == <span class="number">0</span>:</div><div class="line">                    result.append([nums[i], nums[left], nums[right]])</div><div class="line">                    <span class="comment"># 去重</span></div><div class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</div><div class="line">                        left += <span class="number">1</span></div><div class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right<span class="number">-1</span>]:</div><div class="line">                        right -= <span class="number">1</span></div><div class="line">                    left += <span class="number">1</span></div><div class="line">                    right -= <span class="number">1</span></div><div class="line">                <span class="keyword">elif</span> threeSum &lt; <span class="number">0</span>:</div><div class="line">                    left += <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    right -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（11. 盛最多水的容器）</title>
    <url>/2019/08/18/leetCodeTencent50-19/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"> </p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,8,6,2,5,4,8,3,7]</div><div class="line">输出: 49</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="external">https://leetcode-cn.com/problems/container-with-most-water</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先想到的就是暴力计算，结果一测试就超时了，然后改进了一下跳过了一些不必要计算的点，结果还是超时，看来要用其他办法。</p>
<p>想了一会没想出来，参考了一下别人的，<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/" target="_blank" rel="external">https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/</a> </p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></div><div class="line">        result = -float(<span class="string">'inf'</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)<span class="number">-1</span>):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(height)):</div><div class="line">                area = (j - i)*min(height[j], height[i])</div><div class="line">                <span class="keyword">if</span> area &gt; result:</div><div class="line">                    result = area</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p><strong>代码 2</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></div><div class="line">        result = -float(<span class="string">'inf'</span>)</div><div class="line">        maxleft = -float(<span class="string">'inf'</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)<span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> height[i] &lt;= maxleft:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                maxleft = height[i]</div><div class="line">            maxright = -float(<span class="string">'inf'</span>)</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(height)<span class="number">-1</span>, i, <span class="number">-1</span>):</div><div class="line">                <span class="keyword">if</span> height[j] &lt;= maxright:</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    maxright = height[j]</div><div class="line">                area = (j - i)*min(height[j], height[i])</div><div class="line">                <span class="keyword">if</span> area &gt; result:</div><div class="line">                    result = area</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p><strong>代码 3</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></div><div class="line">        result = -float(<span class="string">'inf'</span>)</div><div class="line">        left = <span class="number">0</span></div><div class="line">        right = len(height) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> left &lt; right:</div><div class="line">            result = max(result, (right - left)*min(height[right], height[left]))</div><div class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</div><div class="line">                left += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                right -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（4. 寻找两个有序数组的中位数）</title>
    <url>/2019/08/17/leetCodeTencent50-18/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">nums1 = [1, 3]</div><div class="line">nums2 = [2]</div><div class="line"></div><div class="line">则中位数是 2.0</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">nums1 = [1, 2]</div><div class="line">nums2 = [3, 4]</div><div class="line"></div><div class="line">则中位数是 (2 + 3)/2 = 2.5</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>从时间复杂度来看，只有二分法能达到这样的要求，但没啥思路，先写个普通的排序</p>
<p>参考了一下别人的，最通俗易解的是这个思路：两个有序数组求中位数，问题一般化为，求两个有序数组的第k个数，当k = (m+n)/2时为原问题的解 。</p>
<p>怎么求第k个数？分别求出第一个nums1和第二个数组nums2的第 k / 2个数 a 和 b，然后比较 a 和 b，当a &lt; b ，说明第 k 个数肯定不位于nums1的前半段，去除a的前k/2个数，然后递归求新的num1和nums2的第k-k/2个数就行。</p>
<p>一直递归到k/2等于1位置，时间复杂度为O(logk)=O(log(m+n)/2)=O(log(m+n))</p>
<p>自己按这个思路写了个，结果虽然通过了，但很慢</p>
<p>又按照原版的java改成了python，结果还是很慢，但原版是很快的，可能是不同编程语言的原因吧</p>
<p>#代码</p>
<p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span> </div><div class="line">        m = len(nums1)</div><div class="line">        n = len(nums2)</div><div class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> n % <span class="number">2</span>:</div><div class="line">                <span class="keyword">return</span> nums2[n//<span class="number">2</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> (nums2[n//<span class="number">2</span>] + nums2[n//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> m % <span class="number">2</span>:</div><div class="line">                <span class="keyword">return</span> nums1[m//<span class="number">2</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> (nums1[m//<span class="number">2</span>] + nums1[m//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></div><div class="line">        result = []</div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</div><div class="line">            <span class="keyword">if</span> nums1[i] &lt;= nums2[j]:</div><div class="line">                result.append(nums1[i])</div><div class="line">                i += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result.append(nums2[j])</div><div class="line">                j += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> i == m:</div><div class="line">            result.extend(nums2[j:])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            result.extend(nums1[i:])</div><div class="line">        <span class="keyword">return</span> result[(m+n)//<span class="number">2</span>] <span class="keyword">if</span> (m+n)%<span class="number">2</span> <span class="keyword">else</span> (result[(m+n)//<span class="number">2</span>]+result[(m+n)//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></div><div class="line">        m = len(nums1)</div><div class="line">        n = len(nums2)</div><div class="line">        <span class="comment"># 处理任何一个数组为空的情况</span></div><div class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> n%<span class="number">2</span>:</div><div class="line">                <span class="keyword">return</span> nums2[n//<span class="number">2</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> (nums2[n//<span class="number">2</span>] + nums2[n//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> m%<span class="number">2</span>:</div><div class="line">                <span class="keyword">return</span> nums1[m//<span class="number">2</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> (nums1[m//<span class="number">2</span>] + nums1[m//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></div><div class="line">        total = m + n</div><div class="line">        <span class="keyword">if</span> total % <span class="number">2</span>:</div><div class="line">            <span class="comment"># 总数为奇数，问题转化为找第 total // 2 + 1 个数</span></div><div class="line">            <span class="keyword">return</span> self.findKth(nums1, nums2, total//<span class="number">2</span> + <span class="number">1</span>) </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 总数为偶数，问题转化为找第 total // 2 个数和第total // 2 + 1个数</span></div><div class="line">            <span class="keyword">return</span> (self.findKth(nums1.copy(), nums2.copy(), total//<span class="number">2</span>) + self.findKth(nums1, nums2, total//<span class="number">2</span> + <span class="number">1</span>))/<span class="number">2</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span><span class="params">(self, nums1, nums2, k)</span>:</span></div><div class="line">        <span class="comment"># 当其中一个数组为空时，则第k个数为另外一个数组第k个数</span></div><div class="line">        <span class="keyword">if</span> len(nums1) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> nums2[k<span class="number">-1</span>]</div><div class="line">        <span class="keyword">if</span> len(nums2) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> nums1[k<span class="number">-1</span>]</div><div class="line">        <span class="comment"># k为1时，两数组最小的那个为第1个数</span></div><div class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> min(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>])</div><div class="line">        <span class="comment"># a、b分别表示nums1数组、nums2数组中第 k//2 个数</span></div><div class="line">        a = float(<span class="string">'inf'</span>)</div><div class="line">        b = float(<span class="string">'inf'</span>)</div><div class="line">        <span class="keyword">if</span> k//<span class="number">2</span> &lt;= len(nums1):</div><div class="line">            a = nums1[k//<span class="number">2</span> - <span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> k//<span class="number">2</span> &lt;= len(nums2):</div><div class="line">            b = nums2[k//<span class="number">2</span> - <span class="number">1</span>]</div><div class="line">        <span class="comment"># 当a &lt; b ，说明第 k 个数肯定不位于nums1的前半段，去除a的前k//2个数; 同理b &lt; a也一样</span></div><div class="line">        <span class="comment"># 由于范围缩小了 k // 2 个数，此时总的第 k 个数实际上等于新的范围内的第 k - k // 2个数，依次递归</span></div><div class="line">        <span class="keyword">if</span> a &lt; b:</div><div class="line">            nums1[<span class="number">0</span>:(k//<span class="number">2</span>)] = []</div><div class="line">            <span class="keyword">return</span> self.findKth(nums1, nums2, k - k//<span class="number">2</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            nums2[<span class="number">0</span>:(k//<span class="number">2</span>)] = []</div><div class="line">            <span class="keyword">return</span> self.findKth(nums1, nums2, k - k//<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><strong>代码 3:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></div><div class="line">        m = len(nums1)</div><div class="line">        n = len(nums2)</div><div class="line">        <span class="comment"># 处理任何一个数组为空的情况</span></div><div class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> n%<span class="number">2</span>:</div><div class="line">                <span class="keyword">return</span> nums2[n//<span class="number">2</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> (nums2[n//<span class="number">2</span>] + nums2[n//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> m%<span class="number">2</span>:</div><div class="line">                <span class="keyword">return</span> nums1[m//<span class="number">2</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> (nums1[m//<span class="number">2</span>] + nums1[m//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></div><div class="line">        total = m + n</div><div class="line">        <span class="keyword">if</span> total % <span class="number">2</span>:</div><div class="line">            <span class="comment"># 总数为奇数，问题转化为找第 total // 2 + 1 个数</span></div><div class="line">            <span class="keyword">return</span> self.findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total//<span class="number">2</span> + <span class="number">1</span>) </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 总数为偶数，问题转化为找第 total // 2 个数和第total // 2 + 1个数</span></div><div class="line">            <span class="keyword">return</span> (self.findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total//<span class="number">2</span>) + self.findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total//<span class="number">2</span> + <span class="number">1</span>))/<span class="number">2</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span><span class="params">(self, nums1, i, nums2, j, k)</span>:</span></div><div class="line">        <span class="comment"># 当其中一个数组为空时，则第k个数为另外一个数组第k个数</span></div><div class="line">        <span class="keyword">if</span> len(nums1) == i:</div><div class="line">            <span class="keyword">return</span> nums2[j + k<span class="number">-1</span>]</div><div class="line">        <span class="keyword">if</span> len(nums2) == j:</div><div class="line">            <span class="keyword">return</span> nums1[i + k<span class="number">-1</span>]</div><div class="line">        <span class="comment"># k为1时，两数组最小的那个为第1个数</span></div><div class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> min(nums1[i], nums2[j])</div><div class="line">        <span class="comment"># a、b分别表示nums1数组、nums2数组中第 k//2 个数</span></div><div class="line">        a = float(<span class="string">'inf'</span>)</div><div class="line">        b = float(<span class="string">'inf'</span>)</div><div class="line">        <span class="keyword">if</span> i + k//<span class="number">2</span> &lt;= len(nums1):</div><div class="line">            a = nums1[i + k//<span class="number">2</span> - <span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> j + k//<span class="number">2</span> &lt;= len(nums2):</div><div class="line">            b = nums2[j + k//<span class="number">2</span> - <span class="number">1</span>]</div><div class="line">        <span class="comment"># 当a &lt; b ，说明第 k 个数肯定不位于nums1的前半段，去除a的前k//2个数; 同理b &lt; a也一样</span></div><div class="line">        <span class="comment"># 由于范围缩小了 k // 2 个数，此时总的第 k 个数实际上等于新的范围内的第 k - k // 2个数，依次递归</span></div><div class="line">        <span class="keyword">if</span> a &lt; b:</div><div class="line">            <span class="keyword">return</span> self.findKth(nums1, i + k//<span class="number">2</span>, nums2, j, k - k//<span class="number">2</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> self.findKth(nums1, i, nums2, j + k//<span class="number">2</span>, k - k//<span class="number">2</span>)</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（292. Nim 游戏）</title>
    <url>/2019/08/15/leetCodeTencent50-17/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 4</div><div class="line">输出: false </div><div class="line">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</div><div class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/nim-game" target="_blank" rel="external">https://leetcode-cn.com/problems/nim-game</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一开始看到<a href="https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105" target="_blank" rel="external">Nim游戏</a>，因为不懂就点链接过去看了下，看到了下面的定义：</p>
<p>1.无法进行任何移动的局面（也就是terminal position）是P-position；</p>
<p>2.可以移动到P-position的局面是N-position（先手必胜 ）；</p>
<p>3.所有移动都导致N-position的局面是P-position （先手必败 ）</p>
<p>然后就根据这个写了个递归，一测试结果超出了时间限制。看了下难度是简单，可能是我把它想复杂了。根据递归结果not(a and b and c)发现，3个真得出接下来一个假，一个假又得出3个真，规律是<strong>3真+1假+3真+1假+…</strong>，刚好4次一个循环</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n: int)</span> -&gt; bool:</span></div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> n &gt;=<span class="number">1</span> <span class="keyword">and</span> n &lt;= <span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        a = self.canWinNim(n<span class="number">-1</span>)</div><div class="line">        b = self.canWinNim(n<span class="number">-2</span>)</div><div class="line">        c = self.canWinNim(n<span class="number">-3</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">not</span>(a <span class="keyword">and</span> b <span class="keyword">and</span> c)</div></pre></td></tr></table></figure>
<p><strong>代码 2</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n: int)</span> -&gt; bool:</span></div><div class="line">        <span class="keyword">return</span> n%<span class="number">4</span> != <span class="number">0</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n: int)</span> -&gt; bool:</span></div><div class="line">        <span class="keyword">return</span> n%<span class="number">4</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n: int)</span> -&gt; bool:</span></div><div class="line">        <span class="keyword">return</span> n &amp; <span class="number">3</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（146. LRU缓存机制）</title>
    <url>/2019/08/15/leetCodeTencent50-16/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</div><div class="line"></div><div class="line">cache.put(1, 1);</div><div class="line">cache.put(2, 2);</div><div class="line">cache.get(1);       // 返回  1</div><div class="line">cache.put(3, 3);    // 该操作会使得密钥 2 作废</div><div class="line">cache.get(2);       // 返回 -1 (未找到)</div><div class="line">cache.put(4, 4);    // 该操作会使得密钥 1 作废</div><div class="line">cache.get(1);       // 返回 -1 (未找到)</div><div class="line">cache.get(3);       // 返回  3</div><div class="line">cache.get(4);       // 返回  4</div></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中 。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="external">https://leetcode-cn.com/problems/lru-cache</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题正常获取和写入可以用dict实现，重点在于缓存机制的实现，采用了笨办法：用一个list记住最近使用的key,越往后越近。测试后但出现了一个小问题，就是dict出现相同的键会默认保存后一个键值，而list可以保存重复值，这样它们的键值就会不同步。不同步通过添加一个key是否已经在dict中的判断条件可以解决。</p>
<p>但测试后又出现了新问题，有一个测试用例结果不一致：我的没找到结果是-1，标准答案却找到了对应的键值。这说明我多删掉了键，而代码中只有缓存达到上限时，才有删除键的操作。找了一下发现还是上面的问题衍生出的，原来是先确认缓存删除操作，再执行是否键已经存在，这个执行顺序会在缓存达到上限，但键已经存在的情况下，删掉不该删的键；通过调换它们的先后顺序解决</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></div><div class="line">        self.cap = capacity</div><div class="line">        self.res = &#123;&#125;</div><div class="line">        self.mark = []</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></div><div class="line">        <span class="comment"># return self.res.get(key, default=-1)</span></div><div class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.res:</div><div class="line">            self.mark.remove(key)</div><div class="line">            self.mark.append(key)</div><div class="line">            <span class="keyword">return</span> self.res[key]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.res:</div><div class="line">            self.mark.remove(key)</div><div class="line">            <span class="keyword">del</span> self.res[key]</div><div class="line">        <span class="keyword">if</span> len(self.res) == self.cap:</div><div class="line">            <span class="keyword">del</span> self.res[self.mark[<span class="number">0</span>]]</div><div class="line">            self.mark.pop(<span class="number">0</span>)</div><div class="line">        self.mark.append(key)</div><div class="line">        self.res[key] = value    </div><div class="line">        </div><div class="line">        </div><div class="line"></div><div class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></div><div class="line"><span class="comment"># obj = LRUCache(capacity)</span></div><div class="line"><span class="comment"># param_1 = obj.get(key)</span></div><div class="line"><span class="comment"># obj.put(key,value)</span></div></pre></td></tr></table></figure>
<p><strong>代码 2</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></div><div class="line">        self.cap = capacity</div><div class="line">        self.res = &#123;&#125;</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></div><div class="line">        <span class="comment"># return self.res.get(key, default=-1)</span></div><div class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.res:</div><div class="line">            t = self.res[key]</div><div class="line">            <span class="keyword">del</span> self.res[key]</div><div class="line">            self.res[key] = t</div><div class="line">            <span class="keyword">return</span> t</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.res:</div><div class="line">            <span class="keyword">del</span> self.res[key]</div><div class="line">        <span class="keyword">if</span> len(self.res) == self.cap:</div><div class="line">            <span class="keyword">del</span> self.res[list(self.res.keys())[<span class="number">0</span>]]</div><div class="line">        self.res[key] = value</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（236. 二叉树的最近公共祖先）</title>
    <url>/2019/08/14/leetCodeTencent50-15/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"> </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</div><div class="line">输出: 3</div><div class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</div><div class="line">输出: 5</div><div class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</div></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中 。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="external">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>类似于上一题二叉<strong>搜索</strong>树的最近公共祖先，上一题是根据输入值根节点与p、q的大小来分成三类递归的，但现在题目变成了二叉树，没有大小来分类了，没有输入值那就只能根据<strong>输出值（返回值）</strong>来判断了。想了一会，没想出怎么返回的，最后参考了一下别人的，还是分成三类：</p>
<p>1.p、q其中一个是根节点，则返回根节点</p>
<p>2.求p、q在左子树中是否存在，根据存在与否返回不同值</p>
<p>3.求p、q在右子树中是否存在，根据存在与否返回不同值</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> root.val == p.val <span class="keyword">or</span> root.val == q.val:</div><div class="line">            <span class="keyword">return</span> root</div><div class="line">        l = self.lowestCommonAncestor(root.left, p, q)</div><div class="line">        r = self.lowestCommonAncestor(root.right, p, q)</div><div class="line">        <span class="keyword">if</span> l <span class="keyword">and</span> r:</div><div class="line">            <span class="keyword">return</span> root</div><div class="line">        <span class="keyword">if</span> l <span class="keyword">and</span> (<span class="keyword">not</span> r):</div><div class="line">            <span class="keyword">return</span> l</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> l) <span class="keyword">and</span> r:</div><div class="line">            <span class="keyword">return</span> r</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> l) <span class="keyword">and</span> (<span class="keyword">not</span> r):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（235. 二叉搜索树的最近公共祖先）</title>
    <url>/2019/08/14/leetCodeTencent50-14/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"> </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</div><div class="line">输出: 6 </div><div class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</div><div class="line">输出: 2</div><div class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</div></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="external">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>因为是二叉搜索树，所以首先想到可以根据大小来分类，根据p、q与根节点的关系分为三类：</p>
<p>1.p、q值大小在根节点值两边，则根节点就是最近公共祖先</p>
<p>2.p、q值都小于根节点值，则该树的最近公共祖先等于左子树的最近公共祖先</p>
<p>3.p、q值都大于根节点值，则该树的最近公共祖先等于右子树的最近公共祖先</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></div><div class="line">        <span class="keyword">if</span> (root.val &gt;= p.val <span class="keyword">and</span> root.val &lt;= q.val) <span class="keyword">or</span> (root.val &lt;= p.val <span class="keyword">and</span> root.val &gt;= q.val):</div><div class="line">            <span class="keyword">return</span> root</div><div class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</div><div class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</div><div class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</div><div class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（230. 二叉搜索树中第K小的元素）</title>
    <url>/2019/08/13/leetCodeTencent50-13/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p>
<p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>， </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: root = [3,1,4,null,2], k = 1</div><div class="line">   3</div><div class="line">  / \</div><div class="line"> 1   4</div><div class="line">  \</div><div class="line">   2</div><div class="line">输出: 1</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</div><div class="line">       5</div><div class="line">      / \</div><div class="line">     3   6</div><div class="line">    / \</div><div class="line">   2   4</div><div class="line">  /</div><div class="line"> 1</div><div class="line">输出: 3</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst" target="_blank" rel="external">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>开始想到的直接遍历所有节点，将值保存在列表里，将问题转化为前面做过的（215. 数组中的第K个最大元素）。后来又看了下题目，原来是<strong>二叉搜索树</strong>，这样采用<strong>中序搜索</strong>就只要遍历到第k个节点就可以了</p>
<p>再次提交后，发现时间跟原来一样，检查了一下发现遍历的不止k个节点，修改了一下，虽然只保存了k个值在列表里，但本质上还是遍历了所有节点，还返回了每次的值</p>
<p>最快的其实应该是只中序遍历k个节点，就提前终止返回第k个值，参考了一下别人的，使用yield生成器可以实现,但结果反而是3个方法中最慢的，不知道是为什么？</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    result = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></div><div class="line">        self.result = []</div><div class="line">        self.findAllValue(root)</div><div class="line">        self.result.sort()</div><div class="line">        <span class="keyword">return</span> self.result[k<span class="number">-1</span>]</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAllValue</span><span class="params">(self, node: TreeNode)</span>:</span></div><div class="line">        <span class="keyword">if</span> node:</div><div class="line">            self.result.append(node.val)</div><div class="line">            self.findAllValue(node.left)</div><div class="line">            self.findAllValue(node.right)</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    result = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int, flag= True)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> (len(self.result) != k):</div><div class="line">            self.kthSmallest(root.left, k, <span class="keyword">False</span>)</div><div class="line">            self.result.append(root.val)</div><div class="line">            self.kthSmallest(root.right, k, <span class="keyword">False</span>)</div><div class="line">        <span class="keyword">return</span> self.result[k<span class="number">-1</span>] <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="number">0</span></div><div class="line"><span class="comment"># 修改后</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    result = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int, flag= True)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">if</span> flag:</div><div class="line">            self.result = []</div><div class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> (len(self.result) != k):</div><div class="line">            self.kthSmallest(root.left, k, <span class="keyword">False</span>)</div><div class="line">            <span class="keyword">if</span> len(self.result) != k:</div><div class="line">                self.result.append(root.val)</div><div class="line">            self.kthSmallest(root.right, k, <span class="keyword">False</span>)</div><div class="line">        <span class="keyword">return</span> self.result[k<span class="number">-1</span>] <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p><strong>代码 3:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></div><div class="line">        result = self.findAllValue(root)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</div><div class="line">            result.__next__()</div><div class="line">        <span class="keyword">return</span> result.__next__()</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAllValue</span><span class="params">(self, node: TreeNode)</span>:</span></div><div class="line">        <span class="keyword">if</span> node:</div><div class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self.findAllValue(node.left)</div><div class="line">            <span class="keyword">yield</span> node.val</div><div class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self.findAllValue(node.right)</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（124. 二叉树中的最大路径和）</title>
    <url>/2019/08/13/leetCodeTencent50-12/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>， </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3]</div><div class="line"></div><div class="line">       1</div><div class="line">      / \</div><div class="line">     2   3</div><div class="line"></div><div class="line">输出: 6</div></pre></td></tr></table></figure>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [-10,9,20,null,null,15,7]</div><div class="line"></div><div class="line">   -10</div><div class="line">   / \</div><div class="line">  9  20</div><div class="line">    /  \</div><div class="line">   15   7</div><div class="line"></div><div class="line">输出: 42</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="external">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a> </p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先想到的是递归实现，最大路径和 = 根节点的值 + 左子树最大路径和 + 右子树最大路径和，但这个递推式要成立要一个前提条件：左子树路径的终点是根节点的儿子节点，同理右子树。</p>
<p>修改后，根节点终点最大路径和result1 = 根节点的值<strong>V </strong>+ max（左子树根节点终点最大路径和<strong>L </strong>， 右子树根节点终点最大路径和<strong>R</strong>），但测试后还是有两个问题：第一个是当<strong>L</strong>或<strong>R</strong>的值小于0时，不应该相加，这可以通过取它们和0的<strong>最大值</strong>解决</p>
<p>第二个问题是最大路径可以不经过根节点，这个没想出来，参考了一下别人的，不经过根节点最大路径和result2 = max(所有子树经过根节点的最大路径和) = 根节点的值<strong>V </strong>+ 左子树根节点终点最大路径和<strong>L </strong> + 右子树根节点终点最大路径和<strong>R</strong></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    maxPath = -float(<span class="string">'inf'</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode, flag= True)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        l = max(self.maxPathSum(root.left, <span class="keyword">False</span>), <span class="number">0</span>)</div><div class="line">        r = max(self.maxPathSum(root.right, <span class="keyword">False</span>), <span class="number">0</span>)</div><div class="line">        result1 = root.val + max(l, r)</div><div class="line">        result2 = root.val + l + r</div><div class="line">        self.maxPath = max(self.maxPath, result2)</div><div class="line">        <span class="keyword">return</span> self.maxPath <span class="keyword">if</span> flag <span class="keyword">else</span> result1</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（104. 二叉树的最大深度）</title>
    <url>/2019/08/12/leetCodeTencent50-11/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>， </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  3</div><div class="line"> / \</div><div class="line">9  20</div><div class="line">  /  \</div><div class="line"> 15   7</div></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。 </p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="external">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a> </p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>动态规划用递归实现，最大深度 = max(左子树最大深度，右子树最大深度) + 1</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for a binary tree node.</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        l = root.left</div><div class="line">        r = root.right</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> l) <span class="keyword">and</span> (<span class="keyword">not</span> r):</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            result = max(self.maxDepth(l), self.maxDepth(r)) + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（2的幂）</title>
    <url>/2019/08/12/leetCodeTencent50-10/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 1</div><div class="line">输出: true</div><div class="line">解释: 20 = 1</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 16</div><div class="line">输出: true</div><div class="line">解释: 24 = 16</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 218</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="external">https://leetcode-cn.com/problems/power-of-two/</a> </p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>开始用的暴力计算，但提交超出了时间限制，修改了一下可以了。后来想到2的幂二进制联系起来，它的二进制表示都只有一个1</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n: int)</span> -&gt; bool:</span></div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">while</span> n%<span class="number">2</span> == <span class="number">0</span>:</div><div class="line">            n /= <span class="number">2</span></div><div class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n: int)</span> -&gt; bool:</span></div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="comment"># n = bin(n)</span></div><div class="line">        n &amp;= (n<span class="number">-1</span>)</div><div class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（169. 求众数）</title>
    <url>/2019/08/12/leetCodeTencent50-9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [3,2,3]</div><div class="line">输出: 3</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [2,2,1,1,1,2,2]</div><div class="line">输出: 2</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="external">https://leetcode-cn.com/problems/majority-element/</a> </p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>开始用的暴力计数，但提交超出了时间限制。因为众数超过了n/2,所以排序后中间的位置一定是众数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span>       </div><div class="line">        majorityNum = len(nums)//<span class="number">2</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            count = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums:</div><div class="line">                <span class="keyword">if</span> j == i:</div><div class="line">                    count += <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> count &gt; majorityNum:</div><div class="line">                    <span class="keyword">return</span> i</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span>       </div><div class="line">        nums.sort()     </div><div class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（136. 只出现一次的数字）</title>
    <url>/2019/08/12/leetCodeTencent50-8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [2,2,1]</div><div class="line">输出: 1</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [4,1,2,1,2]</div><div class="line">输出: 4</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="external">https://leetcode-cn.com/problems/single-number</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>没想到既满足时间复杂度又满足空间复杂度的方法，参考了一下别人的</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        result = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            result = result ^ i</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（78. 子集）</title>
    <url>/2019/08/11/leetCodeTencent50-7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: nums = [1,2,3]</div><div class="line">输出:</div><div class="line">[</div><div class="line">  [3],</div><div class="line">  [1],</div><div class="line">  [2],</div><div class="line">  [1,2,3],</div><div class="line">  [1,3],</div><div class="line">  [2,3],</div><div class="line">  [1,2],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets" target="_blank" rel="external">https://leetcode-cn.com/problems/subsets</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>从单个元素来看，每个元素都有在和不在子集两种选择，总共就有2^n选择也就是2^n个子集</p>
<p>用动态规划，每新增一个元素，新的子集=原来的子集（不加新元素）+新增的子集（加入新元素）</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></div><div class="line">        result = [[]]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> result:</div><div class="line">                add = [i] + j</div><div class="line">                result = result + [add]</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（148. 排序链表）</title>
    <url>/2019/08/10/leetCodeTencent50-6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: 4-&gt;2-&gt;1-&gt;3</div><div class="line">输出: 1-&gt;2-&gt;3-&gt;4</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</div><div class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="external">https://leetcode-cn.com/problems/sort-list/</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>虽然实现了，但时间复杂度超了，参考了一下别人的</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>代码 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></div><div class="line">        res = t = end= ListNode(<span class="number">0</span>)</div><div class="line">        res.next = head</div><div class="line">        <span class="keyword">while</span> head:</div><div class="line">            flag = <span class="keyword">True</span></div><div class="line">            <span class="keyword">while</span> head <span class="keyword">and</span> head.next <span class="keyword">and</span> (head.next != end):</div><div class="line">                t.val = head.val</div><div class="line">                <span class="keyword">if</span> head.val &gt; head.next.val:</div><div class="line">                    head.val = head.next.val</div><div class="line">                    head.next.val = t.val</div><div class="line">                    head = head.next</div><div class="line">                    flag = <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                end = head</div><div class="line">            head = res.next</div><div class="line">            <span class="keyword">if</span> flag == <span class="keyword">True</span>:</div><div class="line">                <span class="keyword">return</span> head</div></pre></td></tr></table></figure>
<p><strong>代码 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head <span class="comment"># termination.</span></div><div class="line">        <span class="comment"># cut the LinkedList at the mid index.</span></div><div class="line">        slow, fast = head, head.next</div><div class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</div><div class="line">            fast, slow = fast.next.next, slow.next</div><div class="line">        mid, slow.next = slow.next, <span class="keyword">None</span> <span class="comment"># save and cut.</span></div><div class="line">        <span class="comment"># recursive for cutting.</span></div><div class="line">        left, right = self.sortList(head), self.sortList(mid)</div><div class="line">        <span class="comment"># merge `left` and `right` linked list and return it.</span></div><div class="line">        h = res = ListNode(<span class="number">0</span>)</div><div class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</div><div class="line">            <span class="keyword">if</span> left.val &lt; right.val: h.next, left = left, left.next</div><div class="line">            <span class="keyword">else</span>: h.next, right = right, right.next</div><div class="line">            h = h.next</div><div class="line">        h.next = left <span class="keyword">if</span> left <span class="keyword">else</span> right</div><div class="line">        <span class="keyword">return</span> res.next</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（122. 买卖股票的最佳时机 II）</title>
    <url>/2019/08/09/leetCodeTencent50-5/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [7,1,5,3,6,4]</div><div class="line">输出: 7</div><div class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</div><div class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [1,2,3,4,5]</div><div class="line">输出: 4</div><div class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</div><div class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</div><div class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</div></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [7,6,4,3,1]</div><div class="line">输出: 0</div><div class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="external">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>直接每一天的价格减去前一天的，大于零的加到利润上，这样就行了</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></div><div class="line">        maxp = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</div><div class="line">            p = prices[i+<span class="number">1</span>] - prices[i]</div><div class="line">            <span class="keyword">if</span> p &gt; <span class="number">0</span>:</div><div class="line">                maxp += p</div><div class="line">        <span class="keyword">return</span> maxp</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（23. 合并K个排序链表）</title>
    <url>/2019/08/08/leetCodeTencent50-4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。  </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入:</div><div class="line">[</div><div class="line">  1-&gt;4-&gt;5,</div><div class="line">  1-&gt;3-&gt;4,</div><div class="line">  2-&gt;6</div><div class="line">]</div><div class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="external">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>链表的值赋给list，然后排序，最后又赋值回新的链表</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Definition for singly-linked list.</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></div><div class="line">        newlist = []</div><div class="line">        newnode = []</div><div class="line">        <span class="keyword">if</span> len(lists) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</div><div class="line">            <span class="keyword">while</span> node:</div><div class="line">                newlist.append(node.val)</div><div class="line">                node = node.next</div><div class="line">        newlist.sort()</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(newlist)):</div><div class="line">            newnode.append(ListNode(newlist[i]))</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(newlist)<span class="number">-1</span>):</div><div class="line">            newnode[i].next = newnode[i+<span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> len(newnode) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">return</span> newnode[<span class="number">0</span>]</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（215. 数组中的第K个最大元素）</title>
    <url>/2019/08/05/leetCodeTencent50-3/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [3,2,1,5,6,4] 和 k = 2</div><div class="line">输出: 5</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</div><div class="line">输出: 4</div></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array" target="_blank" rel="external">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>直接排序即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></div><div class="line">        nums.sort(reverse=<span class="keyword">True</span>)</div><div class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（20. 有效的括号）</title>
    <url>/2019/08/05/leetCodeTencent50-2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>​    1.左括号必须用相同类型的右括号闭合。<br>    2.左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="external">https://leetcode-cn.com/problems/valid-parentheses</a></p>
<p><strong>示例1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;()&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure></p>
<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;()[]&#123;&#125;&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<p><strong>示例3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;(]&quot;</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<p><strong>示例4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;([)]&quot;</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<p><strong>示例5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输入: &quot;&#123;[]&#125;&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>从题目的示例来看，有效字符串的括号都是要一对一对的，因此可以采用左括号进栈；遇到右括号和栈中最后一个配对就出栈，不配对就是无效字符串</p>
<p>采用list类型来实现进出栈，对字符串进行遍历即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></div><div class="line">        stack = []</div><div class="line">        <span class="keyword">for</span> bracket <span class="keyword">in</span> s:        </div><div class="line">            <span class="keyword">if</span> bracket == <span class="string">'('</span> <span class="keyword">or</span> bracket == <span class="string">'&#123;'</span> <span class="keyword">or</span> bracket == <span class="string">'['</span>:</div><div class="line">                stack.append(bracket)</div><div class="line">            <span class="keyword">elif</span> len(stack) == <span class="number">0</span> <span class="keyword">and</span> (bracket == <span class="string">')'</span> <span class="keyword">or</span> bracket == <span class="string">'&#125;'</span> <span class="keyword">or</span> bracket == <span class="string">']'</span>):</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">elif</span> bracket == <span class="string">')'</span>:</div><div class="line">                <span class="keyword">if</span> stack[<span class="number">-1</span>] == <span class="string">'('</span>:</div><div class="line">                    stack.pop()</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">elif</span> bracket == <span class="string">'&#125;'</span>:</div><div class="line">                <span class="keyword">if</span> stack[<span class="number">-1</span>] == <span class="string">'&#123;'</span>:</div><div class="line">                    stack.pop()</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">elif</span> bracket == <span class="string">']'</span>:</div><div class="line">                <span class="keyword">if</span> stack[<span class="number">-1</span>] == <span class="string">'['</span>:</div><div class="line">                    stack.pop()</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>leetcode腾讯精选练习50题（155. 最小栈）</title>
    <url>/2019/08/04/leetCodeTencent50-1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。</p>
<p><strong>示例:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MinStack minStack = new MinStack();</div><div class="line">minStack.push(-2);</div><div class="line">minStack.push(0);</div><div class="line">minStack.push(-3);</div><div class="line">minStack.getMin();   --&gt; 返回 -3.</div><div class="line">minStack.pop();</div><div class="line">minStack.top();      --&gt; 返回 0.</div><div class="line">minStack.getMin();   --&gt; 返回 -2.</div></pre></td></tr></table></figure></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="external">https://leetcode-cn.com/problems/min-stack</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>从题目来看，选择了list类型来保存数据，然后push(x)，pop()的功能使用list自带的方法可以实现，top() 使用list的索引也可以实现，该题的重点在于getMin()的实现，但遍历元素又不行，因为要求在常数时间内，即O(1)时间复杂度。</p>
<p>所以采用其他变量来保存最小元素，开始考虑的是采用numbers类型，但运行测试后发现pop后最小值无法回溯；最采用list保存最小元素解决了问题</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ol>
<li><p>使用了list保存数据，int保存最小元素。运行结果出现问题（pop后最小值无法回溯）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        initialize your data structure here.</div><div class="line">        """</div><div class="line">        self.data = []</div><div class="line">        self.minData = float(<span class="string">'inf'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        self.data.append(x)</div><div class="line">        <span class="keyword">if</span> x &lt; self.minData:</div><div class="line">            self.minData = x</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        self.data.pop()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">return</span> self.data[<span class="number">-1</span>]</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">return</span> self.minData</div></pre></td></tr></table></figure>
</li>
<li><p>使用了list保存数据，同时list保存最小元素，运行通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        initialize your data structure here.</div><div class="line">        """</div><div class="line">        self.data = []</div><div class="line">        self.minData = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        self.data.append(x)</div><div class="line">        <span class="keyword">if</span> len(self.minData) == <span class="number">0</span>:</div><div class="line">            self.minData.append(x)</div><div class="line">        <span class="keyword">elif</span> x &lt; self.minData[<span class="number">-1</span>]:</div><div class="line">            self.minData.append(x)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.minData.append(self.minData[<span class="number">-1</span>])</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></div><div class="line">        self.data.pop()</div><div class="line">        self.minData.pop()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">return</span> self.data[<span class="number">-1</span>]</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></div><div class="line">        <span class="keyword">return</span> self.minData[<span class="number">-1</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></div><div class="line"><span class="comment"># obj = MinStack()</span></div><div class="line"><span class="comment"># obj.push(x)</span></div><div class="line"><span class="comment"># obj.pop()</span></div><div class="line"><span class="comment"># param_3 = obj.top()</span></div><div class="line"><span class="comment"># param_4 = obj.getMin()</span></div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Markdown的基本使用</title>
    <url>/2018/10/24/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><ul>
<li>列表1</li>
<li>列表2<ul>
<li>子列表1</li>
<li>子列表2</li>
</ul>
</li>
</ul>
<hr>
<p><a href="https://jwzeng.github.io/" target="_blank" rel="external">链接</a></p>
<p><img src="http://demo.sc.chinaz.com/Files/pic/icons/7504/f4.png" alt="苹果"></p>
<p><em>字体是斜线的了</em></p>
<p><strong>字体加粗了</strong></p>
<p><code>&lt;html&gt;&lt;/html&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">	&lt;title&gt;我是标题哦&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>我的内容是引用哦</p>
</blockquote>
]]></content>
      <categories>
        <category>入门教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2012常见快捷键</title>
    <url>/2018/10/23/VS2012shortcutKey/</url>
    <content><![CDATA[<p>ctrl + J:调用智能提示<br>ctrl + shift + 空格：调用参数信息提示<br>ctrl + G:跳到指定的某一行<br>ctrl + K + C/U：注释/取消注释<br>ctrl + F：查找<br>F12：跳转到定义<br>shift + F12：查找所有引用</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo配置博客</title>
    <url>/2018/10/23/hello-world/</url>
    <content><![CDATA[<p><img src="https://portablehexo.bitmoe.cn/hexopp/hexop.png" alt=""></p>
<blockquote>
<p><strong>本版本仅适用于Win环境</strong><br>本文关键字： <strong>Hexo绿色版</strong>，<strong>Hexo便携版</strong>，<strong>Hexo配置</strong>，<strong>Hexo</strong>，<strong>U盘</strong></p>
</blockquote>
<p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。</p>
<p>但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。</p>
<p>所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。</p>
<p>####<strong>版本介绍</strong><br>那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。</p>
<p>本便携版（Release 1.0.0）所包含的软件如下：</p>
<blockquote>
<ul>
<li>Git: 2.7.4</li>
<li>Nodejs: 6.10.1</li>
<li>Npm: 4.4.1</li>
<li>Hexo: 3.2.2</li>
</ul>
</blockquote>
<p>为了便携的需要，不能配置固定的环境变量，所以除此之外还有相应的批处理文件，下文将详细介绍。</p>
<p>####<strong>从零开始，1分钟搭建Hexo写作环境</strong><br>说了这么多，我们这就开始教你如何在1分钟内，从零开始搭建Hexo写作环境！</p>
<p>#####1 注册一个Github帐号</p>
<p>1.1 进入<a href="https://github.com" target="_blank" rel="external">Github</a>，并在右边的3个框框中分别填写 用户名、邮箱地址、账户密码，并点击 <strong><code>Sign up for Github</code></strong>;</p>
<p><img src="https://portablehexo.bitmoe.cn/hexopp/hexop2.png" alt="图1.1.1"></p>
<p>1.2 进入欢迎页面后，点击<strong><code>Finish sign up</code></strong>;</p>
<p><img src="https://portablehexo.bitmoe.cn/hexopp/hexop3.png" alt="图1.2.1"></p>
<p>1.3 进入到这一步之后（<strong>图1.3.1</strong>），先别记着点任何东西，查看你的邮箱，应该会收到如下的邮件（<strong>图1.3.2</strong>），确认你的邮件。否则，你会看到错误页面（<strong>图1.3.3</strong>）。query完毕之后在<strong>图1.3.1</strong>所示的页面，点击<strong><code>+ New repository</code></strong>;</p>
<p><img src="https://portablehexo.bitmoe.cn/hexopp/hexop5.png" alt="图1.3.1"></p>
<p><img src="https://portablehexo.bitmoe.cn/hexopp/hexop6.png" alt="图1.3.2"></p>
<p><img src="https://portablehexo.bitmoe.cn/hexopp/hexop7.png" alt="图1.3.3"></p>
<p>1.4 请在红框中的 <strong><code>Repository name</code></strong> 里面输入 <strong><code>用户名.github.io</code></strong> ( <strong>用户名</strong> 就是你刚刚 <strong>步骤1.1</strong> 中注册的用户名)，然后点击 <strong><code>Create repository</code></strong>;</p>
<p><img src="https://portablehexo.bitmoe.cn/hexopp/hexop8.png" alt="图1.4.1"></p>
<p>1.5 至此，Github网页注册的部分完毕</p>
<p>####2 下载HEXO Portable</p>
<p>2.1 访问我们的 <a href="https://project.bitmoe.cn/PortableHexo/" target="_blank" rel="external">HEXO Portable</a> 页面，或者 <a href="https://github.com/Bitmoe/PortableHexo" target="_blank" rel="external">Github仓库</a> 下载最新的便携版；</p>
<p>2.2 双击得到的自解压文件，解压到你需要安装博客的地方，可以选择硬盘或者U盘；</p>
<p>####3 配置你的环境</p>
<p>3.1 在你的博客的文件夹，你会发现很多批处理文件，我先介绍下各个文件的用途：</p>
<blockquote>
<ul>
<li>配置基本信息 &gt;&gt; 配置博客的基本环境</li>
<li>配置Github部署 &gt;&gt; 配置博客的部署</li>
<li>启动命令行 &gt;&gt; 启动带环境变量的Git-Bash，否则无法使用node、npm、git等命令</li>
<li>新建文章 &gt;&gt; 新建一篇文章</li>
<li>渲染并本地测试 &gt;&gt; 生成并本地预览</li>
<li>渲染并部署 &gt;&gt; 生成并部署到GitHub</li>
<li>重置配置文件 &gt;&gt; 重置_config.yml</li>
</ul>
</blockquote>
<p>3.2 我们继续进行环境配置，双击<strong><code>配置基本信息</code></strong>并按顺序输入以下信息：</p>
<blockquote>
<ul>
<li>主标题：顾名思义</li>
<li>副标题：顾名思义</li>
<li>描述：顾名思义</li>
<li>作者：顾名思义</li>
<li>网站地址：填写 <strong>用户名.github.io</strong> （此处的用户名为<strong>步骤1.1</strong>中填写的用户名）<br><strong>如果您已经购买了域名，可以参看相关的文章！</strong></li>
</ul>
</blockquote>
<p>3.3 双击<strong><code>配置Github部署</code></strong>并按顺序输入以下信息：</p>
<blockquote>
<ul>
<li>Github的用户名：此处的用户名为<strong>步骤1.1</strong>中填写的用户名</li>
<li>Github注册邮箱：此处的注册邮箱为<strong>步骤1.1</strong>中填写的注册邮箱</li>
</ul>
</blockquote>
<p>3.4 输入完毕之后，会进行测试部署，等待屏幕提示<strong>下面将进行部署测试，稍后将有一个openssh的对话框出现，请输入你的github用户密码。</strong>的时候，按回车继续；（此处的用户密码为<strong>步骤1.1</strong>中填写的用户密码）</p>
<p>3.5 然后继续等待，此时屏幕会出现n多行，耐心等待即可；</p>
<p>3.6 等待屏幕提示<strong>请访问 <a href="https://用户名.github.io" target="_blank" rel="external">https://用户名.github.io</a> 查看是否部署成功！</strong>的时候，在浏览器中输入<strong><a href="https://用户名.github.io" target="_blank" rel="external">https://用户名.github.io</a> </strong>，理论上可以看到你的Hexo站点！（此处的用户名为<strong>步骤1.1</strong>中填写的用户名）</p>
<p>3.7 至此，你的Hexo环境就配置完成了，这样你的这个Hexo博客文件夹无论移动到哪一台电脑，都能通过<strong>启动命令行</strong>出现的bash命令行，或者其余便捷的批处理文件比如<strong>新建文章</strong>、<strong>渲染并本地测试</strong>、<strong>渲染并部署</strong>进行相应的操作。</p>
<p>3.8 如果你在配置中出错，可以运行<strong>重置配置文件</strong>后，再重复<strong>3.1~3.6步骤</strong></p>
<p>####4 开始享受纯粹的Hexo写作吧！</p>
<p>####5 备注</p>
<blockquote>
<ul>
<li>本便携版以及本文均使用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external">CC BY-NC-SA 4.0</a>协议；</li>
<li>本文所有权归 <a href="http://qistchan.com" target="_blank" rel="external">QistChan</a> &amp; <a href="https://wwww.bitmoe.com" target="_blank" rel="external">Bitmoe Inc.</a> 所有；</li>
<li>本便携版由 <a href="https://www.bitmoe.com" target="_blank" rel="external">Bitmoe Inc.</a> 维护并提供技术支持；</li>
<li>需要技术支持可以在<a href="https://github.com/Bitmoe/PortableHexo" target="_blank" rel="external">Github仓库</a> 提交<strong><code>Issues</code></strong>；</li>
<li>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</li>
</ul>
</blockquote>
]]></content>
  </entry>
</search>
